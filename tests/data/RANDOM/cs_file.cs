{"func": "using System;\nusing System.Linq;\n\ninternal class Program\n{\n    private static void Main()\n    {\n        Console.WriteLine(String.Concat(Enumerable.Range('a', 26).Select(c => (char)c)));\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\npublic class Amb : IDisposable\n{\n    List<IValueSet> streams = new List<IValueSet>();\n    List<IAssertOrAction> assertsOrActions = new List<IAssertOrAction>();\n    volatile bool stopped = false;\n\n    public IAmbValue<T> DefineValues<T>(params T[] values)\n    {\n        return DefineValueSet(values);\n    }\n\n    public IAmbValue<T> DefineValueSet<T>(IEnumerable<T> values)\n    {\n        ValueSet<T> stream = new ValueSet<T>();\n        stream.Enumerable = values;\n        streams.Add(stream);\n        return stream;\n    }\n\n    public Amb Assert(Func<bool> function)\n    {\n        assertsOrActions.Add(new AmbAssert()\n        {\n            Level = streams.Count,\n            IsValidFunction = function\n        });\n        return this;\n    }\n\n    public Amb Perform(Action action)\n    {\n        assertsOrActions.Add(new AmbAction()\n        {\n            Level = streams.Count,\n            Action = action\n        });\n        return this;\n    }\n\n    public void Stop()\n    {\n        stopped = true;\n    }\n\n    public void Dispose()\n    {\n        RunLevel(0, 0);\n        if (!stopped)\n        {\n            throw new AmbException();\n        }\n    }\n\n    void RunLevel(int level, int actionIndex)\n    {\n        while (actionIndex < assertsOrActions.Count && assertsOrActions[actionIndex].Level <= level)\n        {\n            if (!assertsOrActions[actionIndex].Invoke() || stopped)\n                return;\n            actionIndex++;\n        }\n        if (level < streams.Count)\n        {\n            using (IValueSetIterator iterator = streams[level].CreateIterator())\n            {\n                while (iterator.MoveNext())\n                {\n                    RunLevel(level + 1, actionIndex);\n                }\n            }\n        }\n    }\n\n    interface IValueSet\n    {\n        IValueSetIterator CreateIterator();\n    }\n\n    interface IValueSetIterator : IDisposable\n    {\n        bool MoveNext();\n    }\n\n    interface IAssertOrAction\n    {\n        int Level { get; }\n        bool Invoke();\n    }\n\n    class AmbAssert : IAssertOrAction\n    {\n        internal int Level;\n        internal Func<bool> IsValidFunction;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            return IsValidFunction();\n        }\n    }\n\n    class AmbAction : IAssertOrAction\n    {\n        internal int Level;\n        internal Action Action;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            Action(); return true;\n        }\n    }\n\n    class ValueSet<T> : IValueSet, IAmbValue<T>, IValueSetIterator\n    {\n        internal IEnumerable<T> Enumerable;\n        private IEnumerator<T> enumerator;\n\n        public T Value { get { return enumerator.Current; } }\n\n        public IValueSetIterator CreateIterator()\n        {\n            enumerator = Enumerable.GetEnumerator();\n            return this;\n        }\n\n        public bool MoveNext()\n        {\n            return enumerator.MoveNext();\n        }\n\n        public void Dispose()\n        {\n            enumerator.Dispose();\n        }\n    }\n}\n\npublic interface IAmbValue<T>\n{\n    T Value { get; }\n}\n\npublic class AmbException : Exception\n{\n    public AmbException() : base(\"AMB is angry\") { }\n}\n"}
{"func": "using System;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace MadLibs_RosettaCode\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tstring madLibs =\n@\"Write a program to create a Mad Libs like story.\nThe program should read an arbitrary multiline story from input.\nThe story will be terminated with a blank line.\nThen, find each replacement to be made within the story,\nask the user for a word to replace it with, and make all the replacements.\nStop when there are none left and print the final story.\nThe input should be an arbitrary story in the form:\n<name> went for a walk in the park. <he or she>\nfound a <noun>. <name> decided to take it home.\nGiven this example, it should then ask for a name,\na he or she and a noun (<name> gets replaced both times with the same value).\";\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tRegex pattern = new Regex(@\"\\<(.*?)\\>\");\n\t\t\tstring storyLine;\n\t\t\tstring replacement;\n\n\t\t\tConsole.WriteLine(madLibs + Environment.NewLine + Environment.NewLine);\n\t\t\tConsole.WriteLine(\"Enter a story: \");\n\n\t\t\t// Continue to get input while empty line hasn't been entered.\n\t\t\tdo\n\t\t\t{\n\t\t\t\tstoryLine = Console.ReadLine();\n\t\t\t\tsb.Append(storyLine + Environment.NewLine);\n\t\t\t} while (!string.IsNullOrEmpty(storyLine) && !string.IsNullOrWhiteSpace(storyLine));\n\n\t\t\t// Retrieve only the unique regex matches from the user entered story.\n\t\t\tMatch nameMatch = pattern.Matches(sb.ToString()).OfType<Match>().Where(x => x.Value.Equals(\"<name>\")).Select(x => x.Value).Distinct() as Match;\n\t\t\tif(nameMatch != null)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + nameMatch.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\t\t\t\tsb.Replace(nameMatch.Value, replacement);\n\t\t\t}\n\n\t\t\tforeach (Match match in pattern.Matches(sb.ToString()))\n\t\t\t{\n\t\t\t\treplacement = string.Empty;\n\t\t\t\t// Guarantee we get a non-whitespace value for the replacement\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + match.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\n\t\t\t\tint location = sb.ToString().IndexOf(match.Value);\n\t\t\t\tsb.Remove(location, match.Value.Length).Insert(location, replacement);\n\t\t\t}\n\n\t\t\tConsole.WriteLine(Environment.NewLine + Environment.NewLine + \"--[ Here's your story! ]--\");\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t}\n}\n"}
{"func": "using System; //DateTime, Console, Environment classes\nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        //Add event handler for Ctrl+C command\n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"func": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tconst float T0 = 100f;\n\t\tconst float TR = 20f;\n\t\tconst float k = 0.07f;\n\t\treadonly static float[] delta_t = {2.0f,5.0f,10.0f};\n\t\tconst int n = 100;\n\t\t\n\t\tpublic delegate float func(float t);\n\t\tstatic float NewtonCooling(float t)\n\t\t{\n\t\t\treturn -k * (t-TR);\t\t\t\n\t\t}\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfunc f = new func(NewtonCooling);\n\t\t\tfor(int i=0; i<delta_t.Length; i++)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"delta_t = \" + delta_t[i]);\n\t\t\t\tEuler(f,T0,n,delta_t[i]);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpublic static void Euler(func f, float y, int n, float h)\n\t\t{\n\t\t\tfor(float x=0; x<=n; x+=h)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"\\t\" + x + \"\\t\" + y);\n\t\t\t\ty += h * f(y);\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"func": "using System;\n\ndelegate int Func2(int a, int b);\n\nclass Program\n{\n    static int Call(Func2 f, int a, int b)\n    {\n        return f(a, b);\n    }\n\n    static void Main()\n    {\n        int a = 6;\n        int b = 2;\n\n        Console.WriteLine(\"f=Add, f({0}, {1}) = {2}\", a, b, Call(delegate(int x, int y) { return x + y; }, a, b));\n        Console.WriteLine(\"f=Mul, f({0}, {1}) = {2}\", a, b, Call(delegate(int x, int y) { return x * y; }, a, b));\n        Console.WriteLine(\"f=Div, f({0}, {1}) = {2}\", a, b, Call(delegate(int x, int y) { return x / y; }, a, b));\n    }\n}\n"}
{"func": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var fileContents = File.ReadAllText(\"c:\\\\autoexec.bat\");\n        // Can optionally take a second parameter to specify the encoding, e.g. File.ReadAllText(\"c:\\\\autoexec.bat\", Encoding.UTF8)\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNumberSequence(\"Fibonacci\", GetNnacciNumbers(2, 10));\n            PrintNumberSequence(\"Lucas\", GetLucasNumbers(10));\n            PrintNumberSequence(\"Tribonacci\", GetNnacciNumbers(3, 10));\n            PrintNumberSequence(\"Tetranacci\", GetNnacciNumbers(4, 10));\n            Console.ReadKey();\n        }\n\n        private static IList<ulong> GetLucasNumbers(int length)\n        {\n            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };\n            return GetFibLikeSequence(seedSequence, length);\n        }\n\n        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)\n        {\n            return GetFibLikeSequence(GetNacciSeed(seedLength), length);\n        }\n\n        private static IList<ulong> GetNacciSeed(int seedLength)\n        {\n            IList<ulong> seedSquence = new List<ulong>() { 1 };\n\n            for (uint i = 0; i < seedLength - 1; i++)\n            {\n                seedSquence.Add((ulong)Math.Pow(2, i));\n            }\n\n            return seedSquence;\n        }\n\n        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)\n        {\n            IList<ulong> sequence = new List<ulong>();\n\n            int count = seedSequence.Count();\n\n            if (length <= count)\n            {\n                sequence = seedSequence.Take((int)length).ToList();\n            }\n            else\n            {\n                sequence = seedSequence;\n\n                for (int i = count; i < length; i++)\n                {\n                    ulong num = 0;\n\n                    for (int j = 0; j < count; j++)\n                    {\n                        num += sequence[sequence.Count - 1 - j];\n                    }\n\n                    sequence.Add(num);\n                }\n            }\n\n            return sequence;\n        }\n\n        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)\n        {\n            StringBuilder output = new StringBuilder(Title).Append(\"   \");\n\n            foreach (long item in numbersequence)\n            {\n                output.AppendFormat(\"{0}, \", item);\n            }\n\n            Console.WriteLine(output.ToString());\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Numerics;\nusing System.IO;\nusing System.Diagnostics;\n\nnamespace Ackermann_Function\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int _m = 0;\n            int _n = 0;\n            Console.Write(\"m = \");\n            try\n            {\n                _m = Convert.ToInt32(Console.ReadLine());\n            }\n            catch (Exception)\n            {\n                Console.WriteLine(\"Please enter a number.\");\n            }\n            Console.Write(\"n = \");\n            try\n            {\n                _n = Convert.ToInt32(Console.ReadLine());\n            }\n            catch (Exception)\n            {\n                Console.WriteLine(\"Please enter a number.\");\n            }\n            //for (long m = 0; m <= 10; ++m)\n            //{\n            //    for (long n = 0; n <= 10; ++n)\n            //    {\n            //        DateTime now = DateTime.Now;\n            //        Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            //        Console.WriteLine(\"Time taken:{0}\", DateTime.Now - now);\n            //    }\n            //}\n\n            DateTime now = DateTime.Now;\n            Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", _m, _n, Ackermann(_m, _n));\n            Console.WriteLine(\"Time taken:{0}\", DateTime.Now - now);\n            File.WriteAllText(\"number.txt\", Ackermann(_m, _n).ToString());\n            Process.Start(\"number.txt\");\n            Console.ReadKey();\n        }\n        public class OverflowlessStack<T>\n        {\n            internal sealed class SinglyLinkedNode\n            {\n                private const int ArraySize = 2048;\n                T[] _array;\n                int _size;\n                public SinglyLinkedNode Next;\n                public SinglyLinkedNode()\n                {\n                    _array = new T[ArraySize];\n                }\n                public bool IsEmpty { get { return _size == 0; } }\n                public SinglyLinkedNode Push(T item)\n                {\n                    if (_size == ArraySize - 1)\n                    {\n                        SinglyLinkedNode n = new SinglyLinkedNode();\n                        n.Next = this;\n                        n.Push(item);\n                        return n;\n                    }\n                    _array[_size++] = item;\n                    return this;\n                }\n                public T Pop()\n                {\n                    return _array[--_size];\n                }\n            }\n            private SinglyLinkedNode _head = new SinglyLinkedNode();\n\n            public T Pop()\n            {\n                T ret = _head.Pop();\n                if (_head.IsEmpty && _head.Next != null)\n                    _head = _head.Next;\n                return ret;\n            }\n            public void Push(T item)\n            {\n                _head = _head.Push(item);\n            }\n            public bool IsEmpty\n            {\n                get { return _head.Next == null && _head.IsEmpty; }\n            }\n        }\n        public static BigInteger Ackermann(BigInteger m, BigInteger n)\n        {\n            var stack = new OverflowlessStack<BigInteger>();\n            stack.Push(m);\n            while (!stack.IsEmpty)\n            {\n                m = stack.Pop();\n            skipStack:\n                if (m == 0)\n                    n = n + 1;\n                else if (m == 1)\n                    n = n + 2;\n                else if (m == 2)\n                    n = n * 2 + 3;\n                else if (n == 0)\n                {\n                    --m;\n                    n = 1;\n                    goto skipStack;\n                }\n                else\n                {\n                    stack.Push(m - 1);\n                    --n;\n                    goto skipStack;\n                }\n            }\n            return n;\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)\n    {\n        var dictionary = new SortedDictionary<TItem, int>();\n        foreach (var item in items)\n        {\n            if (dictionary.ContainsKey(item))\n            {\n                dictionary[item]++;\n            }\n            else\n            {\n                dictionary[item] = 1;\n            }\n        }\n        return dictionary;\n    }\n\n    static void Main(string[] arguments)\n    {\n        var file = arguments.FirstOrDefault();\n        if (File.Exists(file))\n        {\n            var text = File.ReadAllText(file);\n            foreach (var entry in GetFrequencies(text))\n            {\n                Console.WriteLine(\"{0}: {1}\", entry.Key, entry.Value);\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Text;\n\npublic class FloydsTriangle\n{\n    internal static void Main(string[] args)\n    {\n        int count;\n        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)\n        {\n            Console.WriteLine(MakeTriangle(count));\n        }\n        else\n        {\n            Console.WriteLine(MakeTriangle(5));\n            Console.WriteLine();\n            Console.WriteLine(MakeTriangle(14));\n        }\n    }\n\n    public static string MakeTriangle(int rows)\n    {\n        int maxValue = (rows * (rows + 1)) / 2;\n        int digit = 0;\n        StringBuilder output = new StringBuilder();\n\n        for (int row = 1; row <= rows; row++)\n        {\n            for (int column = 0; column < row; column++)\n            {\n                int colMaxDigit = (maxValue - rows) + column + 1;\n                if (column > 0)\n                {\n                    output.Append(' ');\n                }\n\n                digit++;\n                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));\n            }\n\n            output.AppendLine();\n        }\n\n        return output.ToString();\n    }\n}\n"}
{"func": "namespace PriorityQ {\n  using KeyT = UInt32;\n  using System;\n  using System.Collections.Generic;\n  using System.Linq;\n  class Tuple<K, V> { // for DotNet 3.5 without Tuple's\n    public K Item1; public V Item2;\n    public Tuple(K k, V v) { Item1 = k; Item2 = v; }\n    public override string ToString() {\n      return \"(\" + Item1.ToString() + \", \" + Item2.ToString() + \")\";\n    }\n  }\n  class MinHeapPQ<V> {\n    private struct HeapEntry {\n      public KeyT k; public V v;\n      public HeapEntry(KeyT k, V v) { this.k = k; this.v = v; }\n    }\n    private List<HeapEntry> pq;\n    private MinHeapPQ() { this.pq = new List<HeapEntry>(); }\n    private bool mt { get { return pq.Count == 0; } }\n    private int sz {\n      get {\n        var cnt = pq.Count;\n        return (cnt == 0) ? 0 : cnt - 1;\n      }\n    }\n    private Tuple<KeyT, V> pkmn {\n      get {\n        if (pq.Count == 0) return null;\n        else {\n          var mn = pq[0];\n          return new Tuple<KeyT, V>(mn.k, mn.v);\n        }\n      }\n    }\n    private void psh(KeyT k, V v) { // add extra very high item if none\n      if (pq.Count == 0) pq.Add(new HeapEntry(UInt32.MaxValue, v));\n      var i = pq.Count; pq.Add(pq[i - 1]); // copy bottom item...\n      for (var ni = i >> 1; ni > 0; i >>= 1, ni >>= 1) {\n        var t = pq[ni - 1];\n        if (t.k > k) pq[i - 1] = t; else break;\n      }\n      pq[i - 1] = new HeapEntry(k, v);\n    }\n    private void siftdown(KeyT k, V v, int ndx) {\n      var cnt = pq.Count - 1; var i = ndx;\n      for (var ni = i + i + 1; ni < cnt; ni = ni + ni + 1) {\n        var oi = i; var lk = pq[ni].k; var rk = pq[ni + 1].k;\n        var nk = k;\n        if (k > lk) { i = ni; nk = lk; }\n        if (nk > rk) { ni += 1; i = ni; }\n        if (i != oi) pq[oi] = pq[i]; else break;\n      }\n      pq[i] = new HeapEntry(k, v);\n    }\n    private void rplcmin(KeyT k, V v) {\n      if (pq.Count > 1) siftdown(k, v, 0);\n    }\n    private void dltmin() {\n      var lsti = pq.Count - 2;\n      if (lsti <= 0) pq.Clear();\n      else {\n        var lkv = pq[lsti];\n        pq.RemoveAt(lsti); siftdown(lkv.k, lkv.v, 0);\n      }\n    }\n    private void reheap(int i) {\n      var lfti = i + i + 1;\n      if (lfti < sz) {\n        var rghti = lfti + 1; reheap(lfti); reheap(rghti);\n        var ckv = pq[i]; siftdown(ckv.k, ckv.v, i);\n      }\n    }\n    private void bld(IEnumerable<Tuple<KeyT, V>> sq) {\n      var sqm = from e in sq\n                select new HeapEntry(e.Item1, e.Item2);\n      pq = sqm.ToList<HeapEntry>();\n      var sz = pq.Count;\n      if (sz > 0) {\n        var lkv = pq[sz - 1];\n        pq.Add(new HeapEntry(KeyT.MaxValue, lkv.v));\n        reheap(0);\n      }\n    }\n    private IEnumerable<Tuple<KeyT, V>> sq() {\n      return from e in pq\n             where e.k != KeyT.MaxValue\n             select new Tuple<KeyT, V>(e.k, e.v); }\n    private void adj(Func<KeyT, V, Tuple<KeyT, V>> f) {\n      var cnt = pq.Count - 1;\n      for (var i = 0; i < cnt; ++i) {\n        var e = pq[i];\n        var r = f(e.k, e.v);\n        pq[i] = new HeapEntry(r.Item1, r.Item2);\n      }\n      reheap(0);\n    }\n    public static MinHeapPQ<V> empty { get { return new MinHeapPQ<V>(); } }\n    public static bool isEmpty(MinHeapPQ<V> pq) { return pq.mt; }\n    public static int size(MinHeapPQ<V> pq) { return pq.sz; }\n    public static Tuple<KeyT, V> peekMin(MinHeapPQ<V> pq) { return pq.pkmn; }\n    public static MinHeapPQ<V> push(KeyT k, V v, MinHeapPQ<V> pq) {\n      pq.psh(k, v); return pq; }\n    public static MinHeapPQ<V> replaceMin(KeyT k, V v, MinHeapPQ<V> pq) {\n      pq.rplcmin(k, v); return pq; }\n    public static MinHeapPQ<V> deleteMin(MinHeapPQ<V> pq) { pq.dltmin(); return pq; }\n    public static MinHeapPQ<V> merge(MinHeapPQ<V> pq1, MinHeapPQ<V> pq2) {\n      return fromSeq(pq1.sq().Concat(pq2.sq())); }\n    public static MinHeapPQ<V> adjust(Func<KeyT, V, Tuple<KeyT, V>> f, MinHeapPQ<V> pq) {\n      pq.adj(f); return pq; }\n    public static MinHeapPQ<V> fromSeq(IEnumerable<Tuple<KeyT, V>> sq) {\n      var pq = new MinHeapPQ<V>(); pq.bld(sq); return pq; }\n    public static Tuple<Tuple<KeyT, V>, MinHeapPQ<V>> popMin(MinHeapPQ<V> pq) {\n      var rslt = pq.pkmn; if (rslt == null) return null;\n      pq.dltmin(); return new Tuple<Tuple<KeyT, V>, MinHeapPQ<V>>(rslt, pq); }\n    public static IEnumerable<Tuple<KeyT, V>> toSeq(MinHeapPQ<V> pq) {\n      for (; !pq.mt; pq.dltmin()) yield return pq.pkmn; }\n    public static IEnumerable<Tuple<KeyT, V>> sort(IEnumerable<Tuple<KeyT, V>> sq) {\n      return toSeq(fromSeq(sq)); }\n  }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.DoublyLinkedList\n{\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var list = new LinkedList<char>(\"hello\");\n\n            var current = list.First;\n            do\n            {\n                Console.WriteLine(current.Value);\n            } while ((current = current.Next) != null);\n\n            Console.WriteLine();\n\n            current = list.Last;\n            do\n            {\n                Console.WriteLine(current.Value);\n            } while ((current = current.Previous) != null);\n        }\n    }\n}\n"}
{"func": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        //other puzzle types elided\n        hopidoMoves = {(-3,0),(0,-3),(0,3),(3,0),(-2,-2),(-2,2),(2,-2),(2,2)},\n\n    private (int dx, int dy)[] moves;\n\n    public static void Main()\n    {\n        Print(new Solver(hopidoMoves).Solve(false,\n            \".00.00.\",\n            \"0000000\",\n            \"0000000\",\n            \".00000.\",\n            \"..000..\",\n            \"...0...\"\n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaTicTacToe\n{\n  class Program\n  {\n\n    /*================================================================\n     *Pieces (players and board)\n     *================================================================*/\n    static string[][] Players = new string[][] {\n      new string[] { \"COMPUTER\", \"X\" }, // computer player\n      new string[] { \"HUMAN\", \"O\" }     // human player\n    };\n\n    const int Unplayed = -1;\n    const int Computer = 0;\n    const int Human = 1;\n\n    // GameBoard holds index into Players[] (0 or 1) or Unplayed (-1) if location not yet taken\n    static int[] GameBoard = new int[9];\n\n    static int[] corners = new int[] { 0, 2, 6, 8 };\n\n    static int[][] wins = new int[][] {\n      new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 },\n      new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 },\n      new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };\n\n\n    /*================================================================\n     *Main Game Loop (this is what runs/controls the game)\n     *================================================================*/\n    static void Main(string[] args)\n    {\n      while (true)\n      {\n        Console.Clear();\n        Console.WriteLine(\"Welcome to Rosetta Code Tic-Tac-Toe for C#.\");\n        initializeGameBoard();\n        displayGameBoard();\n        int currentPlayer = rnd.Next(0, 2);  // current player represented by Players[] index of 0 or 1\n        Console.WriteLine(\"The first move goes to {0} who is playing {1}s.\\n\", playerName(currentPlayer), playerToken(currentPlayer));\n        while (true)\n        {\n          int thisMove = getMoveFor(currentPlayer);\n          if (thisMove == Unplayed)\n          {\n            Console.WriteLine(\"{0}, you've quit the game ... am I that good?\", playerName(currentPlayer));\n            break;\n          }\n          playMove(thisMove, currentPlayer);\n          displayGameBoard();\n          if (isGameWon())\n          {\n            Console.WriteLine(\"{0} has won the game!\", playerName(currentPlayer));\n            break;\n          }\n          else if (isGameTied())\n          {\n            Console.WriteLine(\"Cat game ... we have a tie.\");\n            break;\n          }\n          currentPlayer = getNextPlayer(currentPlayer);\n        }\n        if (!playAgain())\n          return;\n      }\n    }\n\n    /*================================================================\n     *Move Logic\n     *================================================================*/\n    static int getMoveFor(int player)\n    {\n      if (player == Human)\n        return getManualMove(player);\n      else\n      {\n        //int selectedMove = getManualMove(player);\n        //int selectedMove = getRandomMove(player);\n        int selectedMove = getSemiRandomMove(player);\n        //int selectedMove = getBestMove(player);\n        Console.WriteLine(\"{0} selects position {1}.\", playerName(player), selectedMove + 1);\n        return selectedMove;\n      }\n    }\n\n    static int getManualMove(int player)\n    {\n      while (true)\n      {\n        Console.Write(\"{0}, enter you move (number): \", playerName(player));\n        ConsoleKeyInfo keyInfo = Console.ReadKey();\n        Console.WriteLine();  // keep the display pretty\n        if (keyInfo.Key == ConsoleKey.Escape)\n          return Unplayed;\n        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)\n        {\n          int move = keyInfo.KeyChar - '1';  // convert to between 0..8, a GameBoard index position.\n          if (GameBoard[move] == Unplayed)\n            return move;\n          else\n            Console.WriteLine(\"Spot {0} is already taken, please select again.\", move + 1);\n        }\n        else\n          Console.WriteLine(\"Illegal move, please select again.\\n\");\n      }\n    }\n\n    static int getRandomMove(int player)\n    {\n      int movesLeft = GameBoard.Count(position => position == Unplayed);\n      int x = rnd.Next(0, movesLeft);\n      for (int i = 0; i < GameBoard.Length; i++)  // walk board ...\n      {\n        if (GameBoard[i] == Unplayed && x < 0)    // until we reach the unplayed move.\n          return i;\n        x--;\n      }\n      return Unplayed;\n    }\n\n    // plays random if no winning move or needed block.\n    static int getSemiRandomMove(int player)\n    {\n      int posToPlay;\n      if (checkForWinningMove(player, out posToPlay))\n        return posToPlay;\n      if (checkForBlockingMove(player, out posToPlay))\n        return posToPlay;\n      return getRandomMove(player);\n    }\n\n    // purposely not implemented (this is the thinking part).\n    static int getBestMove(int player)\n    {\n      return -1;\n    }\n\n    static bool checkForWinningMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(player, line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool checkForBlockingMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)\n    {\n      int cnt = 0;\n      posToPlay = int.MinValue;\n      foreach (int pos in line)\n      {\n        if (GameBoard[pos] == player)\n          cnt++;\n        else if (GameBoard[pos] == Unplayed)\n          posToPlay = pos;\n      }\n      return cnt == 2 && posToPlay >= 0;\n    }\n\n    static void playMove(int boardPosition, int player)\n    {\n      GameBoard[boardPosition] = player;\n    }\n\n    static bool isGameWon()\n    {\n      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));\n    }\n\n    static bool takenBySamePlayer(int a, int b, int c)\n    {\n      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];\n    }\n\n    static bool isGameTied()\n    {\n      return !GameBoard.Any(spot => spot == Unplayed);\n    }\n\n    /*================================================================\n     *Misc Methods\n     *================================================================*/\n    static Random rnd = new Random();\n\n    static void initializeGameBoard()\n    {\n      for (int i = 0; i < GameBoard.Length; i++)\n        GameBoard[i] = Unplayed;\n    }\n\n    static string playerName(int player)\n    {\n      return Players[player][0];\n    }\n\n    static string playerToken(int player)\n    {\n      return Players[player][1];\n    }\n\n    static int getNextPlayer(int player)\n    {\n      return (player + 1) % 2;\n    }\n\n    static void displayGameBoard()\n    {\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(0), pieceAt(1), pieceAt(2));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(3), pieceAt(4), pieceAt(5));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(6), pieceAt(7), pieceAt(8));\n      Console.WriteLine();\n    }\n\n    static string pieceAt(int boardPosition)\n    {\n      if (GameBoard[boardPosition] == Unplayed)\n        return (boardPosition + 1).ToString();  // display 1..9 on board rather than 0..8\n      return playerToken(GameBoard[boardPosition]);\n    }\n\n    private static bool playAgain()\n    {\n      Console.WriteLine(\"\\nDo you want to play again?\");\n      return Console.ReadKey(false).Key == ConsoleKey.Y;\n    }\n  }\n\n}\n"}
{"func": "using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing PalindromeDetector.ConsoleApp;\n\nnamespace PalindromeDetector.VisualStudioTests\n{\n    [TestClass]\n    public class VSTests\n    {\n        [TestMethod]\n        public void PalindromeDetectorCanUnderstandPalindrome()\n        {\n            //Microsoft.VisualStudio.QualityTools.UnitTestFramework v4.0.30319\n            bool expected = true;\n            bool actual;\n            actual = Program.IsPalindrome(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindrome(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n        }\n        [TestMethod]\n        public void PalindromeDetecotryCanUnderstandNonPalindrome()\n        {\n            bool notExpected = true;\n            bool actual = Program.IsPalindrome(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Text.RegularExpressions;\n\nclass Program {\n    static void Main(string[] args) {\n        string str = \"I am a string\";\n\n        if (new Regex(\"string$\").IsMatch(str)) {\n            Console.WriteLine(\"Ends with string.\");\n        }\n\n        str = new Regex(\" a \").Replace(str, \" another \");\n        Console.WriteLine(str);\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PartialFunctionApplication\n{\n    static Func<T1, TResult> PartiallyApply<T1, T2, TResult>(Func<T1, T2, TResult> function, T2 argument2)\n    {\n        return argument1 => function(argument1, argument2);\n    }\n\n    static void Main()\n    {\n        var fs = (Func<IEnumerable<int>, Func<int, int>, IEnumerable<int>>)Enumerable.Select;\n        var f1 = (Func<int, int>)(n => n * 2);\n        var f2 = (Func<int, int>)(n => n * n);\n        var fsf1 = PartiallyApply(fs, f1);\n        var fsf2 = PartiallyApply(fs, f2);\n\n        var s = new[] { 0, 1, 2, 3 };\n        Console.WriteLine(string.Join(\", \", fsf1(s)));\n        Console.WriteLine(string.Join(\", \", fsf2(s)));\n\n        s = new[] { 2, 4, 6, 8 };\n        Console.WriteLine(string.Join(\", \", fsf1(s)));\n        Console.WriteLine(string.Join(\", \", fsf2(s)));\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main() {\n        Console.WriteLine(string.Join(\" \", Primes(100)));\n    }\n\n    static IEnumerable<int> Primes(int limit) => Enumerable.Range(2, limit-2).Where(IsPrime);\n    static bool IsPrime(int n) => Enumerable.Range(2, (int)Math.Sqrt(n)-1).All(i => n % i != 0);\n}\n"}
{"func": "using System;\n\nnamespace Y_or_N\n{\n    class Program\n    {\n        static void Main()\n        {\n            bool response = GetYorN();\n        }\n\n        static bool GetYorN()\n        {\n            ConsoleKey response; // Creates a variable to hold the user's response.\n\n            do\n            {\n                while (Console.KeyAvailable) // Flushes the input queue.\n                    Console.ReadKey();\n\n                Console.Write(\"Y or N? \"); // Asks the user to answer with 'Y' or 'N'.\n                response = Console.ReadKey().Key; // Gets the user's response.\n                Console.WriteLine(); // Breaks the line.\n            } while (response != ConsoleKey.Y && response != ConsoleKey.N); // If the user did not respond with a 'Y' or an 'N', repeat the loop.\n\n             /*\n              * Return true if the user responded with 'Y', otherwise false.\n              *\n              * We know the response was either 'Y' or 'N', so we can assume\n              * the response is 'N' if it is not 'Y'.\n              */\n            return response == ConsoleKey.Y;\n        }\n    }\n}\n"}
{"func": "using System.Xml;\nusing System.Xml.Serialization;\n[XmlRoot(\"root\")]\npublic class ExampleXML\n{\n    [XmlElement(\"element\")]\n    public string element = \"Some text here\";\n    static void Main(string[] args)\n    {\n        var xmlnamespace = new XmlSerializerNamespaces();\n        xmlnamespace.Add(\"\", \"\"); //used to stop default namespaces from printing\n        var writer = XmlWriter.Create(\"output.xml\");\n        new XmlSerializer(typeof(ExampleXML)).Serialize(writer, new ExampleXML(), xmlnamespace);\n    }\n    //Output: <?xml version=\"1.0\" encoding=\"utf-8\"?><root><element>Some text here</element></root>\n}\n"}
{"func": "using System;\npublic static class IteratedDigitsSquaring\n{\n    public static void Main() {\n        Console.WriteLine(Count89s(1_000_000));\n        Console.WriteLine(Count89s(100_000_000));\n    }\n\n    public static int Count89s(int limit) {\n        if (limit < 1) return 0;\n        int[] end = new int[Math.Min(limit, 9 * 9 * 9 + 2)];\n        int result = 0;\n\n        for (int i = 1; i < end.Length; i++) {\n            for (end[i] = i; end[i] != 1 && end[i] != 89; end[i] = SquareDigitSum(end[i])) { }\n            if (end[i] == 89) result++;\n        }\n        for (int i = end.Length; i < limit; i++) {\n            if (end[SquareDigitSum(i)] == 89) result++;\n        }\n        return result;\n\n        int SquareDigitSum(int n) {\n            int sum = 0;\n            while (n > 0) {\n                int digit = n % 10;\n                sum += digit * digit;\n                n /= 10;\n            }\n            return sum;\n        }\n    }\n\n}\n"}
{"func": "using System;\n\nnamespace Unbias\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            // Demonstrate.\n            for (int n = 3; n <= 6; n++)\n            {\n                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;\n                for (int i = 0; i < 100000; i++)\n                {\n                    if (randN(n))\n                        biasedOne++;\n                    else\n                        biasedZero++;\n                    if (Unbiased(n))\n                        unbiasedOne++;\n                    else\n                        unbiasedZero++;\n                }\n\n                Console.WriteLine(\"(N = {0}):\".PadRight(17) + \"# of 0\\t# of 1\\t% of 0\\t% of 1\", n);\n                Console.WriteLine(\"Biased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  biasedZero, biasedOne,\n                                  biasedZero/1000, biasedOne/1000);\n                Console.WriteLine(\"Unbiased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  unbiasedZero, unbiasedOne,\n                                  unbiasedZero/1000, unbiasedOne/1000);\n            }\n        }\n\n        private static bool Unbiased(int n)\n        {\n            bool flip1, flip2;\n\n            /* Flip twice, and check if the values are the same.\n             * If so, flip again. Otherwise, return the value of the first flip. */\n\n            do\n            {\n                flip1 = randN(n);\n                flip2 = randN(n);\n            } while (flip1 == flip2);\n\n            return flip1;\n        }\n\n        private static readonly Random random = new Random();\n\n        private static bool randN(int n)\n        {\n            // Has an 1/n chance of returning 1. Otherwise it returns 0.\n            return random.Next(0, n) == 0;\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class TuringMachine\n{\n    public static async Task Main() {\n        var fiveStateBusyBeaver = new TuringMachine(\"A\", '0', \"H\").WithTransitions(\n            (\"A\", '0', '1', Right, \"B\"),\n            (\"A\", '1', '1', Left,  \"C\"),\n            (\"B\", '0', '1', Right, \"C\"),\n            (\"B\", '1', '1', Right, \"B\"),\n            (\"C\", '0', '1', Right, \"D\"),\n            (\"C\", '1', '0', Left,  \"E\"),\n            (\"D\", '0', '1', Left,  \"A\"),\n            (\"D\", '1', '1', Left,  \"D\"),\n            (\"E\", '0', '1', Stay,  \"H\"),\n            (\"E\", '1', '0', Left,  \"A\")\n        );\n        var busyBeaverTask = fiveStateBusyBeaver.TimeAsync();\n\n        var incrementer = new TuringMachine(\"q0\", 'B', \"qf\").WithTransitions(\n            (\"q0\", '1', '1', Right, \"q0\"),\n            (\"q0\", 'B', '1', Stay,  \"qf\")\n        )\n        .WithInput(\"111\");\n        foreach (var _ in incrementer.Run()) PrintLine(incrementer);\n        PrintResults(incrementer);\n\n        var threeStateBusyBeaver = new TuringMachine(\"a\", '0', \"halt\").WithTransitions(\n            (\"a\", '0', '1', Right, \"b\"),\n            (\"a\", '1', '1', Left,  \"c\"),\n            (\"b\", '0', '1', Left,  \"a\"),\n            (\"b\", '1', '1', Right, \"b\"),\n            (\"c\", '0', '1', Left,  \"b\"),\n            (\"c\", '1', '1', Stay,  \"halt\")\n        );\n        foreach (var _ in threeStateBusyBeaver.Run()) PrintLine(threeStateBusyBeaver);\n        PrintResults(threeStateBusyBeaver);\n\n        var sorter = new TuringMachine(\"A\", '*', \"X\").WithTransitions(\n            (\"A\", 'a', 'a', Right, \"A\"),\n            (\"A\", 'b', 'B', Right, \"B\"),\n            (\"A\", '*', '*', Left,  \"E\"),\n            (\"B\", 'a', 'a', Right, \"B\"),\n            (\"B\", 'b', 'b', Right, \"B\"),\n            (\"B\", '*', '*', Left,  \"C\"),\n            (\"C\", 'a', 'b', Left,  \"D\"),\n            (\"C\", 'b', 'b', Left,  \"C\"),\n            (\"C\", 'B', 'b', Left,  \"E\"),\n            (\"D\", 'a', 'a', Left,  \"D\"),\n            (\"D\", 'b', 'b', Left,  \"D\"),\n            (\"D\", 'B', 'a', Right, \"A\"),\n            (\"E\", 'a', 'a', Left,  \"E\"),\n            (\"E\", '*', '*', Right, \"X\")\n        )\n        .WithInput(\"babbababaa\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        sorter.Reset().WithInput(\"bbbababaaabba\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        Console.WriteLine(await busyBeaverTask);\n        PrintResults(fiveStateBusyBeaver);\n\n        void PrintLine(TuringMachine tm) => Console.WriteLine(tm.TapeString + \"\\tState \" + tm.State);\n\n        void PrintResults(TuringMachine tm) {\n            Console.WriteLine($\"End state: {tm.State} = {(tm.Success ? \"Success\" : \"Failure\")}\");\n            Console.WriteLine(tm.Steps + \" steps\");\n            Console.WriteLine(\"tape length: \" + tm.TapeLength);\n            Console.WriteLine();\n        }\n    }\n\n    public const int Left = -1, Stay = 0, Right = 1;\n    private readonly Tape tape;\n    private readonly string initialState;\n    private readonly HashSet<string> terminatingStates;\n    private Dictionary<(string state, char read), (char write, int move, string toState)> transitions;\n\n    public TuringMachine(string initialState, char blankSymbol, params string[] terminatingStates) {\n        State = this.initialState = initialState;\n        tape = new Tape(blankSymbol);\n        this.terminatingStates = terminatingStates.ToHashSet();\n    }\n\n    public TuringMachine WithTransitions(\n        params (string state, char read, char write, int move, string toState)[] transitions)\n    {\n        this.transitions = transitions.ToDictionary(k => (k.state, k.read), k => (k.write, k.move, k.toState));\n        return this;\n    }\n\n    public TuringMachine Reset() {\n        State = initialState;\n        Steps = 0;\n        tape.Reset();\n        return this;\n    }\n\n    public TuringMachine WithInput(string input) {\n        tape.Input(input);\n        return this;\n    }\n\n    public int Steps { get; private set; }\n    public string State { get; private set; }\n    public bool Success => terminatingStates.Contains(State);\n    public int TapeLength => tape.Length;\n    public string TapeString => tape.ToString();\n\n    public IEnumerable<string> Run() {\n        yield return State;\n        while (Step()) yield return State;\n    }\n\n    public async Task<TimeSpan> TimeAsync(CancellationToken cancel = default) {\n        var chrono = Stopwatch.StartNew();\n        await RunAsync(cancel);\n        chrono.Stop();\n        return chrono.Elapsed;\n    }\n\n    public Task RunAsync(CancellationToken cancel = default)\n        => Task.Run(() => {\n            while (Step()) cancel.ThrowIfCancellationRequested();\n        });\n\n    private bool Step() {\n        if (!transitions.TryGetValue((State, tape.Current), out var action)) return false;\n        tape.Current = action.write;\n        tape.Move(action.move);\n        State = action.toState;\n        Steps++;\n        return true;\n    }\n\n\n    private class Tape\n    {\n        private List<char> forwardTape = new List<char>(), backwardTape = new List<char>();\n        private int head = 0;\n        private char blank;\n\n        public Tape(char blankSymbol) => forwardTape.Add(blank = blankSymbol);\n\n        public void Reset() {\n            backwardTape.Clear();\n            forwardTape.Clear();\n            head = 0;\n            forwardTape.Add(blank);\n        }\n\n        public void Input(string input) {\n            Reset();\n            forwardTape.Clear();\n            forwardTape.AddRange(input);\n        }\n\n        public void Move(int direction) {\n            head += direction;\n            if (head >= 0 && forwardTape.Count <= head) forwardTape.Add(blank);\n            if (head < 0 && backwardTape.Count <= ~head) backwardTape.Add(blank);\n        }\n\n        public char Current {\n            get => head < 0 ? backwardTape[~head] : forwardTape[head];\n            set {\n                if (head < 0) backwardTape[~head] = value;\n                else forwardTape[head] = value;\n            }\n        }\n\n        public int Length => backwardTape.Count + forwardTape.Count;\n\n        public override string ToString() {\n            int h = (head < 0 ? ~head : backwardTape.Count + head) * 2 + 1;\n            var builder = new StringBuilder(\" \", Length * 2 + 1);\n            if (backwardTape.Count > 0) {\n                builder.Append(string.Join(\" \", backwardTape)).Append(\" \");\n                if (head < 0) (builder[h + 1], builder[h - 1]) = ('(', ')');\n                for (int l = 0, r = builder.Length - 1; l < r; l++, r--) (builder[l], builder[r]) = (builder[r], builder[l]);\n            }\n            builder.Append(string.Join(\" \", forwardTape)).Append(\" \");\n            if (head >= 0) (builder[h - 1], builder[h + 1]) = ('(', ')');\n            return builder.ToString();\n        }\n\n    }\n\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class SetPuzzle\n{\n    static readonly Feature[] numbers  = { (1, \"One\"), (2, \"Two\"), (3, \"Three\") };\n    static readonly Feature[] colors   = { (1, \"Red\"), (2, \"Green\"), (3, \"Purple\") };\n    static readonly Feature[] shadings = { (1, \"Open\"), (2, \"Striped\"), (3, \"Solid\") };\n    static readonly Feature[] symbols  = { (1, \"Oval\"), (2, \"Squiggle\"), (3, \"Diamond\") };\n\n    private readonly struct Feature\n    {\n        public Feature(int value, string name) => (Value, Name) = (value, name);\n        public int Value { get; }\n        public string Name { get; }\n        public static implicit operator int(Feature f) => f.Value;\n        public static implicit operator Feature((int value, string name) t) => new Feature(t.value, t.name);\n        public override string ToString() => Name;\n    }\n\n    private readonly struct Card : IEquatable<Card>\n    {\n        public Card(Feature number, Feature color, Feature shading, Feature symbol) =>\n            (Number, Color, Shading, Symbol) = (number, color, shading, symbol);\n\n        public Feature Number { get; }\n        public Feature Color { get; }\n        public Feature Shading { get; }\n        public Feature Symbol { get; }\n\n        public override string ToString() => $\"{Number} {Color} {Shading} {Symbol}(s)\";\n        public bool Equals(Card other) => Number == other.Number && Color == other.Color && Shading == other.Shading && Symbol == other.Symbol;\n    }\n\n    public static void Main() {\n        Card[] deck = (\n            from number in numbers\n            from color in colors\n            from shading in shadings\n            from symbol in symbols\n            select new Card(number, color, shading, symbol)\n        ).ToArray();\n        var random = new Random();\n\n        Deal(deck, 9, 4, random);\n        Console.WriteLine();\n        Console.WriteLine();\n        Deal(deck, 12, 6, random);\n    }\n\n    static void Deal(Card[] deck, int size, int target, Random random) {\n        List<(Card a, Card b, Card c)> sets;\n        do {\n            Shuffle(deck, random.Next);\n            sets = (\n                from i in 0.To(size - 2)\n                from j in (i + 1).To(size - 1)\n                from k in (j + 1).To(size)\n                select (deck[i], deck[j], deck[k])\n            ).Where(IsSet).ToList();\n        } while (sets.Count != target);\n        Console.WriteLine(\"The board:\");\n        foreach (Card card in deck.Take(size)) Console.WriteLine(card);\n        Console.WriteLine();\n        Console.WriteLine(\"Sets:\");\n        foreach (var s in sets) Console.WriteLine(s);\n    }\n\n    static void Shuffle<T>(T[] array, Func<int, int, int> rng) {\n        for (int i = 0; i < array.Length; i++) {\n            int r = rng(i, array.Length);\n            (array[r], array[i]) = (array[i], array[r]);\n        }\n    }\n\n    static bool IsSet((Card a, Card b, Card c) t) =>\n        AreSameOrDifferent(t.a.Number, t.b.Number, t.c.Number) &&\n        AreSameOrDifferent(t.a.Color, t.b.Color, t.c.Color) &&\n        AreSameOrDifferent(t.a.Shading, t.b.Shading, t.c.Shading) &&\n        AreSameOrDifferent(t.a.Symbol, t.b.Symbol, t.c.Symbol);\n\n    static bool AreSameOrDifferent(int a, int b, int c) => (a + b + c) % 3 == 0;\n    static IEnumerable<int> To(this int start, int end) => Range(start, end - start - 1);\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string pokemon_names = @\"audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon\ncresselia croagunk darmanitan deino emboar emolga exeggcute gabite\ngirafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan\nkricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine\nnosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2\nporygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking\nsealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko\ntyrogue vigoroth vulpix wailord wartortle whismur wingull yamask\";\n\n            string[] pokemon = pokemon_names.Split(new char[]{' ','\\n'});\n            List<string> chain = new List<string>(pokemon.Length);\n\n            for (int i = 0; i < pokemon.Length; i++)\n            {\n                swap(ref pokemon[0], ref pokemon[i]);\n                Search( pokemon, chain, 1 );\n                swap(ref pokemon[0], ref pokemon[i]);\n            }\n\n            foreach (string s in chain)\n                Console.WriteLine(s);\n\n            Console.ReadKey();\n        }\n\n        static void Search(string[] pokemon, List<string> longest_chain, int len )\n        {\n            if (len > longest_chain.Count)\n            {\n                longest_chain.Clear();\n                for (int i = 0; i < len; i++)\n                    longest_chain.Add(pokemon[i]);\n            }\n\n            char lastchar = pokemon[len - 1][pokemon[len-1].Length - 1];\n            for (int i = len; i < pokemon.Length; i++)\n            {\n                if (pokemon[i][0] == lastchar)\n                {\n                    swap(ref pokemon[i], ref pokemon[len]);\n                    Search(pokemon, longest_chain, len + 1);\n                    swap(ref pokemon[i], ref pokemon[len]);\n                }\n            }\n        }\n\n        static void swap(ref string s1, ref string s2)\n        {\n            string tmp = s1;\n            s1 = s2;\n            s2 = tmp;\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Shapes;\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// namespace: Honeycombs\n//\n// summary:\tWPF implementation of Rosetta Code Honeycombs task.  Uses Polygon shapes as hexes.\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nnamespace Honeycombs\n{\n    public partial class MainWindow\n    {\n        private const int RowCount = 4;\n        private const int ColCount = 5;\n        private const int LabelSize = 20;\n        private readonly char[] _permutedChars;\n\n        public MainWindow()\n        {\n            if (RowCount * ColCount > 26)\n#pragma warning disable 162\n            {\n                throw new ArgumentException(\"Too many cells\");\n            }\n#pragma warning restore 162\n            _permutedChars = GetPermutedChars(RowCount * ColCount);\n\n            // VS Generated code not included\n            InitializeComponent();\n        }\n\n        private static char[] GetPermutedChars(int characterCount)\n        {\n            const string allChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n            var rnd = new Random();\n            var chars = new char[allChars.Length];\n\n            for (int i = 0; i < allChars.Length; i++)\n            {\n                chars[i] = allChars[i];\n            }\n\n            for (int i = 0; i < characterCount; i++)\n            {\n                int swapIndex = rnd.Next() % (allChars.Length - i);\n                char tmp = chars[swapIndex + i];\n                chars[swapIndex + i] = chars[i];\n                chars[i] = tmp;\n            }\n            return chars;\n        }\n\n        private void SetHexProperties(UIElementCollection hexes, double cellSize)\n        {\n            int charIndex = 0;\n            List<Polygon> hexList = hexes.Cast<Polygon>().ToList();\n\n            foreach (Polygon element in hexList)\n            {\n                SetHexProperties(element, _permutedChars[charIndex++], cellSize);\n            }\n        }\n\n        private void SetHexProperties(Polygon hex, char charToSet, double cellSize)\n        {\n            var tag = (Tuple<int, int, double, double>) hex.Tag;\n            double cellX = tag.Item3;\n            double cellY = tag.Item4;\n\n            // We place the text in a grid centered on the hex.\n            // The grid will then center the text within itself.\n\n            var centeringGrid = new Grid();\n            centeringGrid.Width = centeringGrid.Height = 2 * cellSize;\n            centeringGrid.SetValue(Canvas.LeftProperty, cellX - cellSize);\n            centeringGrid.SetValue(Canvas.TopProperty, cellY - cellSize);\n            centeringGrid.IsHitTestVisible = false;\n            HoneycombCanvas.Children.Add(centeringGrid);\n\n            var label = new TextBlock\n                {\n                    Text = new string(charToSet, 1),\n                    FontFamily = new FontFamily(\"Segoe\"),\n                    FontSize = LabelSize\n                };\n            label.HorizontalAlignment = HorizontalAlignment.Center;\n            label.VerticalAlignment = VerticalAlignment.Center;\n            label.IsHitTestVisible = false;\n            centeringGrid.Children.Add(label);\n\n            // Reset the tag to keep track of the character in the hex\n            hex.Tag = charToSet;\n            hex.Fill = new SolidColorBrush(Colors.Yellow);\n            hex.Stroke = new SolidColorBrush(Colors.Black);\n            hex.StrokeThickness = cellSize / 10;\n\n            // Mouse down event handler for the hex\n            hex.MouseDown += hex_MouseDown;\n        }\n\n        private void hex_MouseDown(object sender, MouseButtonEventArgs e)\n        {\n            var hex = sender as Shape;\n            if (hex == null)\n            {\n                throw new InvalidCastException(\"Non-shape in Honeycomb\");\n            }\n\n            // Get the letter for this hex\n            var ch = (char) hex.Tag;\n\n            // Add it to our Letters TextBlock\n            Letters.Text = Letters.Text + ch;\n\n            // Color the hex magenta\n            hex.Fill = new SolidColorBrush(Colors.Magenta);\n\n            // Remove the mouse down event handler so we won't hit on this hex again\n            hex.MouseDown -= hex_MouseDown;\n        }\n\n        private static void GetCombSize(double actualHeight, double actualWidth, int columns, int rows,\n                                        out double cellSize, out double combHeight, out double combWidth)\n        {\n            double columnFactor = (3 * columns + 1) / 2.0;\n            double rowFactor = (Math.Sqrt(3) * (2 * rows + 1)) / 2.0;\n            double cellFromWidth = actualWidth / columnFactor;\n            double cellFromHeight = actualHeight / rowFactor;\n            cellSize = Math.Min(cellFromWidth, cellFromHeight);\n            combWidth = cellSize * columnFactor;\n            combHeight = cellSize * rowFactor;\n        }\n\n        private static void AddCells(Canvas canvas, double cellSize, int columns, int rows)\n        {\n            double rowHeight = cellSize * Math.Sqrt(3) / 2;\n\n            for (int row = 0; row < rows; row++)\n            {\n                AddRow(rowHeight, canvas, cellSize, columns, row);\n                rowHeight += cellSize * Math.Sqrt(3);\n            }\n        }\n\n        private static void AddRow(double rowHeight, Canvas canvas, double cellSize, int columnCount, int row)\n        {\n            double cellX = cellSize;\n            double cellHeight = cellSize * Math.Sqrt(3);\n\n            for (int col = 0; col < columnCount; col++)\n            {\n                double cellY = rowHeight + ((col & 1) == 1 ? cellHeight / 2 : 0);\n                Polygon hex = GetCenteredHex(cellSize, cellX, cellY, cellHeight);\n                hex.Tag = Tuple.Create(col, row, cellX, cellY);\n                canvas.Children.Add(hex);\n                cellX += 3 * cellSize / 2;\n            }\n        }\n\n        private static Polygon GetCenteredHex(double cellSize, double cellX, double cellY, double cellHeight)\n        {\n            var hex = new Polygon();\n            hex.Points.Add(new Point(cellX - cellSize, cellY));\n            hex.Points.Add(new Point(cellX - cellSize / 2, cellY + cellHeight / 2));\n            hex.Points.Add(new Point(cellX + cellSize / 2, cellY + cellHeight / 2));\n            hex.Points.Add(new Point(cellX + cellSize, cellY));\n            hex.Points.Add(new Point(cellX + cellSize / 2, cellY - cellHeight / 2));\n            hex.Points.Add(new Point(cellX - cellSize / 2, cellY - cellHeight / 2));\n            return hex;\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            double combHeight, combWidth, cellSize;\n\n            // Get sizes that will fit within our window\n            GetCombSize(Main.ActualHeight, Main.ActualWidth, ColCount, RowCount, out cellSize, out combHeight,\n                        out combWidth);\n\n            // Set the canvas size appropriately\n            HoneycombCanvas.Width = combWidth;\n            HoneycombCanvas.Height = combHeight;\n\n            // Add the cells to the canvas\n            AddCells(HoneycombCanvas, cellSize, ColCount, RowCount);\n\n            // Set the cells to look like we want them\n            SetHexProperties(HoneycombCanvas.Children, cellSize);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.IO;\n\nnamespace TruncateFile\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            TruncateFile(args[0], long.Parse(args[1]));\n        }\n\n        private static void TruncateFile(string path, long length)\n        {\n            if (!File.Exists(path))\n                throw new ArgumentException(\"No file found at specified path.\", \"path\");\n\n            using (var fileStream = new FileStream(path, FileMode.Open, FileAccess.Write))\n            {\n                if (fileStream.Length < length)\n                    throw new ArgumentOutOfRangeException(\"length\",\n                                                          \"The specified length is greater than that of the file.\");\n\n                fileStream.SetLength(length);\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace LZW\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            List<int> compressed = Compress(\"TOBEORNOTTOBEORTOBEORNOT\");\n            Console.WriteLine(string.Join(\", \", compressed));\n            string decompressed = Decompress(compressed);\n            Console.WriteLine(decompressed);\n        }\n\n        public static List<int> Compress(string uncompressed)\n        {\n            // build the dictionary\n            Dictionary<string, int> dictionary = new Dictionary<string, int>();\n            for (int i = 0; i < 256; i++)\n                dictionary.Add(((char)i).ToString(), i);\n\n            string w = string.Empty;\n            List<int> compressed = new List<int>();\n\n            foreach (char c in uncompressed)\n            {\n                string wc = w + c;\n                if (dictionary.ContainsKey(wc))\n                {\n                    w = wc;\n                }\n                else\n                {\n                    // write w to output\n                    compressed.Add(dictionary[w]);\n                    // wc is a new sequence; add it to the dictionary\n                    dictionary.Add(wc, dictionary.Count);\n                    w = c.ToString();\n                }\n            }\n\n            // write remaining output if necessary\n            if (!string.IsNullOrEmpty(w))\n                compressed.Add(dictionary[w]);\n\n            return compressed;\n        }\n\n        public static string Decompress(List<int> compressed)\n        {\n            // build the dictionary\n            Dictionary<int, string> dictionary = new Dictionary<int, string>();\n            for (int i = 0; i < 256; i++)\n                dictionary.Add(i, ((char)i).ToString());\n\n            string w = dictionary[compressed[0]];\n            compressed.RemoveAt(0);\n            StringBuilder decompressed = new StringBuilder(w);\n\n            foreach (int k in compressed)\n            {\n                string entry = null;\n                if (dictionary.ContainsKey(k))\n                    entry = dictionary[k];\n                else if (k == dictionary.Count)\n                    entry = w + w[0];\n\n                decompressed.Append(entry);\n\n                // new sequence; add it to the dictionary\n                dictionary.Add(dictionary.Count, w + entry[0]);\n\n                w = entry;\n            }\n\n            return decompressed.ToString();\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int n_iter = 10;\n\t\tstatic int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 };\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\tConsole.WriteLine(\"\");\t\t\t\n\t\t\t\n\t\t\tint[] g = new int[f.Length];\n\t\t\tfor( int n=n_iter; n!=0; n-- )\n\t\t\t{\n\t\t\t\tfor( int i=1; i<f.Length-1; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];\n\t\t\t\t\telse if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;\n\t\t\t\t\telse g[i] = 0;\n\t\t\t\t}\n\t\t\t\tg[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;\n\t\t\t\tg[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0;\n\t\t\t\t\n\t\t\t\tint[] tmp = f;\n\t\t\t\tf = g;\n\t\t\t\tg = tmp;\n\t\t\t\t\n\t\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n"}
{"func": "using static System.Console;\nusing static System.Threading.Thread;\nusing System;\n\npublic static class PenneysGame\n{\n    const int pause = 500;\n    const int N = 3;\n    static Random rng = new Random();\n\n    static int Toss() => rng.Next(2);\n\n    static string AsString(this int sequence) {\n        string s = \"\";\n        for (int b = 0b100; b > 0; b >>= 1) {\n            s += (sequence & b) > 0 ? 'T' : 'H';\n        }\n        return s;\n    }\n\n    static int UserInput() {\n        while (true) {\n            switch (ReadKey().Key) {\n                case ConsoleKey.Escape: return -1;\n                case ConsoleKey.H: return 0;\n                case ConsoleKey.T: return 1;\n            }\n            Console.Write('\\b');\n        }\n    }\n\n    public static void Main2() {\n        int yourScore = 0, myScore = 0;\n        while (true) {\n            WriteLine($\"Your score: {yourScore}, My score: {myScore}\");\n            WriteLine(\"Determining who goes first...\");\n            Sleep(pause);\n            bool youStart = Toss() == 1;\n            WriteLine(youStart ? \"You go first.\" : \"I go first.\");\n            int yourSequence = 0, mySequence = 0;\n            if (youStart) {\n                WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                int userChoice;\n                for (int i = 0; i < N; i++) {\n                    if ((userChoice = UserInput()) < 0) return;\n                    yourSequence = (yourSequence << 1) + userChoice;\n                }\n                mySequence = ((~yourSequence << 1) & 0b100) | (yourSequence >> 1);\n            } else {\n                for (int i = 0; i < N; i++) {\n                    mySequence = (mySequence << 1) + Toss();\n                }\n\n                WriteLine(\"I chose \" + mySequence.AsString());\n                do {\n                    WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                    int choice;\n                    yourSequence = 0;\n                    for (int i = 0; i < N; i++) {\n                        if ((choice = UserInput()) < 0) return;\n                        yourSequence = (yourSequence << 1) + choice;\n                    }\n                    if (yourSequence == mySequence) {\n                        WriteLine();\n                        WriteLine(\"You cannot choose the same sequence.\");\n                    }\n                } while (yourSequence == mySequence);\n            }\n\n            WriteLine();\n            WriteLine($\"Your sequence: {yourSequence.AsString()}, My sequence: {mySequence.AsString()}\");\n            WriteLine(\"Tossing...\");\n            int sequence = 0;\n            for (int i = 0; i < N; i++) {\n                Sleep(pause);\n                int toss = Toss();\n                sequence = (sequence << 1) + toss;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            while (true) {\n                if (sequence == yourSequence) {\n                    WriteLine();\n                    WriteLine(\"You win!\");\n                    yourScore++;\n                    break;\n                } else if (sequence == mySequence) {\n                    WriteLine();\n                    WriteLine(\"I win!\");\n                    myScore++;\n                    break;\n                }\n                Sleep(pause);\n                int toss = Toss();\n                sequence = ((sequence << 1) + toss) & 0b111;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            WriteLine(\"Press a key.\");\n            ReadKey();\n            Clear();\n        }\n    }\n\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class RangeExtraction\n{\n    public static void Main()\n    {\n        string s = \"0,1,2,4,6,7,8,11,12,14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24,25, 27, 28, 29, 30, 31, 32, 33, 35, 36,37, 38, 39\";\n        Console.WriteLine(string.Join(\",\", Ranges(s.Split(',').Select(int.Parse))\n            .Select(r => r.end == r.start ? $\"{r.start}\" : $\"{r.start}-{r.end}\")));\n    }\n\n    static IEnumerable<(int start, int end)> Ranges(IEnumerable<int> numbers) {\n        if (numbers == null) yield break;\n        var e = numbers.GetEnumerator();\n        if (!e.MoveNext()) yield break;\n\n        int start = e.Current;\n        int end = start;\n        while (e.MoveNext()) {\n            if (e.Current - end != 1) {\n                if (end - start == 1) {\n                    yield return (start, start);\n                    yield return (end, end);\n                } else {\n                    yield return (start, end);\n                }\n                start = e.Current;\n            }\n            end = e.Current;\n        }\n        yield return (start, end);\n    }\n\n}\n"}
{"func": "using System;\nusing System.IO;\n// Needed for the method.\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nstatic class Func {\n    public static Func<T, TResult2> andThen<T, TResult, TResult2>(\n            this Func<T, TResult> @this,\n            Func<TResult, TResult2> after)\n        => _ => after(@this(_));\n}\n\ndelegate OUTPUT SelfApplicable<OUTPUT>(SelfApplicable<OUTPUT> s);\nstatic class SelfApplicable {\n    public static OUTPUT selfApply<OUTPUT>(this SelfApplicable<OUTPUT> @this) => @this(@this);\n}\n\ndelegate FUNCTION FixedPoint<FUNCTION>(Func<FUNCTION, FUNCTION> f);\n\ndelegate OUTPUT VarargsFunction<INPUTS, OUTPUT>(params INPUTS[] inputs);\nstatic class VarargsFunction {\n    public static VarargsFunction<INPUTS, OUTPUT> from<INPUTS, OUTPUT>(\n            Func<INPUTS[], OUTPUT> function)\n        => function.Invoke;\n\n    public static VarargsFunction<INPUTS, OUTPUT> upgrade<INPUTS, OUTPUT>(\n            Func<INPUTS, OUTPUT> function) {\n        return inputs => function(inputs[0]);\n    }\n\n    public static VarargsFunction<INPUTS, OUTPUT> upgrade<INPUTS, OUTPUT>(\n            Func<INPUTS, INPUTS, OUTPUT> function) {\n        return inputs => function(inputs[0], inputs[1]);\n    }\n\n    public static VarargsFunction<INPUTS, POST_OUTPUT> andThen<INPUTS, OUTPUT, POST_OUTPUT>(\n            this VarargsFunction<INPUTS, OUTPUT> @this,\n            VarargsFunction<OUTPUT, POST_OUTPUT> after) {\n        return inputs => after(@this(inputs));\n    }\n\n    public static Func<INPUTS, OUTPUT> toFunction<INPUTS, OUTPUT>(\n            this VarargsFunction<INPUTS, OUTPUT> @this) {\n        return input => @this(input);\n    }\n\n    public static Func<INPUTS, INPUTS, OUTPUT> toBiFunction<INPUTS, OUTPUT>(\n            this VarargsFunction<INPUTS, OUTPUT> @this) {\n        return (input, input2) => @this(input, input2);\n    }\n\n    public static VarargsFunction<PRE_INPUTS, OUTPUT> transformArguments<PRE_INPUTS, INPUTS, OUTPUT>(\n            this VarargsFunction<INPUTS, OUTPUT> @this,\n            Func<PRE_INPUTS, INPUTS> transformer) {\n        return inputs => @this(inputs.AsParallel().AsOrdered().Select(transformer).ToArray());\n    }\n}\n\ndelegate FixedPoint<FUNCTION> Y<FUNCTION>(SelfApplicable<FixedPoint<FUNCTION>> y);\n\nstatic class Program {\n    static TResult Cast<TResult>(this Delegate @this) where TResult : Delegate {\n        return (TResult)Delegate.CreateDelegate(typeof(TResult), @this.Target, @this.Method);\n    }\n\n    static void Main(params String[] arguments) {\n        BigInteger TWO = BigInteger.One + BigInteger.One;\n\n        Func<IFormattable, long> toLong = x => long.Parse(x.ToString());\n        Func<IFormattable, BigInteger> toBigInteger = x => new BigInteger(toLong(x));\n\n        /* Based on https://gist.github.com/aruld/3965968/#comment-604392 */\n        Y<VarargsFunction<IFormattable, IFormattable>> combinator = y => f => x => f(y.selfApply()(f))(x);\n        FixedPoint<VarargsFunction<IFormattable, IFormattable>> fixedPoint =\n            combinator.Cast<SelfApplicable<FixedPoint<VarargsFunction<IFormattable, IFormattable>>>>().selfApply();\n\n        VarargsFunction<IFormattable, IFormattable> fibonacci = fixedPoint(\n            f => VarargsFunction.upgrade(\n                toBigInteger.andThen(\n                    n => (IFormattable)(\n                        (n.CompareTo(TWO) <= 0)\n                        ? 1\n                        : BigInteger.Parse(f(n - BigInteger.One).ToString())\n                            + BigInteger.Parse(f(n - TWO).ToString()))\n                )\n            )\n        );\n\n        VarargsFunction<IFormattable, IFormattable> factorial = fixedPoint(\n            f => VarargsFunction.upgrade(\n                toBigInteger.andThen(\n                    n => (IFormattable)((n.CompareTo(BigInteger.One) <= 0)\n                        ? 1\n                        : n * BigInteger.Parse(f(n - BigInteger.One).ToString()))\n                )\n            )\n        );\n\n        VarargsFunction<IFormattable, IFormattable> ackermann = fixedPoint(\n            f => VarargsFunction.upgrade(\n                (BigInteger m, BigInteger n) => m.Equals(BigInteger.Zero)\n                    ? n + BigInteger.One\n                    : f(\n                        m - BigInteger.One,\n                        n.Equals(BigInteger.Zero)\n                            ? BigInteger.One\n                            : f(m, n - BigInteger.One)\n                    )\n            ).transformArguments(toBigInteger)\n        );\n\n        var functions = new Dictionary<String, VarargsFunction<IFormattable, IFormattable>>();\n        functions.Add(\"fibonacci\", fibonacci);\n        functions.Add(\"factorial\", factorial);\n        functions.Add(\"ackermann\", ackermann);\n\n        var parameters = new Dictionary<VarargsFunction<IFormattable, IFormattable>, IFormattable[]>();\n        parameters.Add(functions[\"fibonacci\"], new IFormattable[] { 20 });\n        parameters.Add(functions[\"factorial\"], new IFormattable[] { 10 });\n        parameters.Add(functions[\"ackermann\"], new IFormattable[] { 3, 2 });\n\n        functions.AsParallel().Select(\n            entry => entry.Key\n                + \"[\" + String.Join(\", \", parameters[entry.Value].Select(x => x.ToString())) + \"]\"\n                + \" = \"\n                + entry.Value(parameters[entry.Value])\n        ).ForAll(Console.WriteLine);\n    }\n}\n"}
{"func": "using System;\nabstract class Printer\n{\n    public abstract void Print();\n}\n\nclass PrinterImpl : Printer\n{\n    public override void Print() {\n        Console.WriteLine(\"Hello world!\");\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\nstatic class Program\n{\n    enum Tenants { Baker = 0, Cooper = 1, Fletcher = 2, Miller = 3, Smith = 4 };\n\n    static void Main()\n    {\n        var count = Enum.GetNames(typeof(Tenants)).Length;\n        var top = count - 1;\n\n        var solve =\n            from f in Range(0, count).Permutations()\n            let floors = f.ToArray()\n            where floors[(int)Tenants.Baker] != top //r1\n            where floors[(int)Tenants.Cooper] != 0 //r2\n            where floors[(int)Tenants.Fletcher] != top && floors[(int)Tenants.Fletcher] != 0 //r3\n            where floors[(int)Tenants.Miller] > floors[(int)Tenants.Cooper] //r4\n            where Math.Abs(floors[(int)Tenants.Smith] - floors[(int)Tenants.Fletcher]) !=1 //r5\n            where Math.Abs(floors[(int)Tenants.Fletcher] - floors[(int)Tenants.Cooper]) !=1 //r6\n            select floors;\n        var solved = solve.First();\n        var output = Range(0,count).OrderBy(i=>solved[i]).Select(f => ((Tenants)f).ToString());\n        Console.WriteLine(String.Join(\" \", output));\n        Console.Read();\n    }\n\n    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n    {\n        if (values.Count() == 1)\n            return values.ToSingleton();\n\n        return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n    }\n\n    public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n}\n"}
{"func": "using System;\nusing System.IO;\n\nnamespace GetLine\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(GetLine(args[0], uint.Parse(args[1])));\n        }\n\n        private static string GetLine(string path, uint line)\n        {\n            using (var reader = new StreamReader(path))\n            {\n                try\n                {\n                    for (uint i = 0; i <= line; i++)\n                    {\n                        if (reader.EndOfStream)\n                            return string.Format(\"There {1} less than {0} line{2} in the file.\", line,\n                                                 ((line == 1) ? \"is\" : \"are\"), ((line == 1) ? \"\" : \"s\"));\n\n                        if (i == line)\n                            return reader.ReadLine();\n\n                        reader.ReadLine();\n                    }\n                }\n                catch (IOException ex)\n                {\n                    return ex.Message;\n                }\n                catch (OutOfMemoryException ex)\n                {\n                    return ex.Message;\n                }\n            }\n\n            throw new Exception(\"Something bad happened.\");\n        }\n    }\n}\n"}
{"func": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Decode(\"http%3A%2F%2Ffoo%20bar%2F\"));\n        }\n\n        private static string Decode(string uri)\n        {\n            return Uri.UnescapeDataString(uri);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class ElementWiseOperations\n{\n    private static readonly Dictionary<string, Func<double, double, double>> operations =\n        new Dictionary<string, Func<double, double, double>> {\n            { \"add\", (a, b) => a + b },\n            { \"sub\", (a, b) => a - b },\n            { \"mul\", (a, b) => a * b },\n            { \"div\", (a, b) => a / b },\n            { \"pow\", (a, b) => Math.Pow(a, b) }\n        };\n\n    private static readonly Func<double, double, double> nothing = (a, b) => a;\n\n    public static double[,] DoOperation(this double[,] m, string name, double[,] other) =>\n        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, other);\n\n    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double[,] other) {\n        if (m == null || other == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        if (rows != other.GetLength(0) || columns != other.GetLength(1)) {\n            throw new ArgumentException(\"Matrices have different dimensions.\");\n        }\n\n        double[,] result = new double[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                result[r, c] = operation(m[r, c], other[r, c]);\n            }\n        }\n        return result;\n    }\n\n    public static double[,] DoOperation(this double[,] m, string name, double number) =>\n        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, number);\n\n    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double number) {\n        if (m == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        double[,] result = new double[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                result[r, c] = operation(m[r, c], number);\n            }\n        }\n        return result;\n    }\n\n    public static void Print(this double[,] m) {\n        if (m == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        for (int r = 0; r < rows; r++) {\n            Console.WriteLine(\"[ \" + string.Join(\", \", Enumerable.Range(0, columns).Select(c => m[r, c])) + \" ]\");\n        }\n    }\n\n}\n\npublic class Program\n{\n    public static void Main() {\n        double[,] matrix = {\n            { 1, 2, 3, 4 },\n            { 5, 6, 7, 8 },\n            { 9, 10, 11, 12 }\n        };\n\n        double[,] tens = {\n            { 10, 10, 10, 10 },\n            { 20, 20, 20, 20 },\n            { 30, 30, 30, 30 }\n        };\n\n        matrix.Print();\n        WriteLine();\n\n        (matrix = matrix.DoOperation(\"add\", tens)).Print();\n        WriteLine();\n\n        matrix.DoOperation((a, b) => b - a, 100).Print();\n    }\n}\n"}
{"func": "using System.Linq;\nusing static System.Console;\n\nnamespace Amb\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n\n            var amb = new Amb();\n\n            var set1 = amb.Choose(\"the\", \"that\", \"a\");\n            var set2 = amb.Choose(\"frog\", \"elephant\", \"thing\");\n            amb.Require(() => set1.Value.Last() == set2.Value[0]);\n            var set3 = amb.Choose(\"walked\", \"treaded\", \"grows\");\n            amb.Require(() => set2.Value.Last() == set3.Value[0]);\n            var set4 = amb.Choose(\"slowly\", \"quickly\");\n            amb.RequireFinal(() => set3.Value.Last() == set4.Value[0]);\n\n            WriteLine($\"{set1} {set2} {set3} {set4}\");\n            Read();\n\n            // problem from http://www.randomhacks.net/articles/2005/10/11/amb-operator\n            amb = new Amb();\n\n            var x = amb.Choose(1, 2, 3);\n            var y = amb.Choose(4, 5, 6);\n            amb.RequireFinal(() => x.Value* y.Value == 8);\n\n            WriteLine($\"{x} * {y} = 8\");\n            Read();\n            Read();\n        }\n    }\n}\n"}
{"func": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Move(\"input.txt\",\"output.txt\");\n        File.Move(@\"\\input.txt\",@\"\\output.txt\");\n\n        Directory.Move(\"docs\",\"mydocs\");\n        Directory.Move(@\"\\docs\",@\"\\mydocs\");\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\n\nnamespace Sutherland\n{\n    public static class SutherlandHodgman\n    {\n        #region Class: Edge\n\n        /// <summary>\n        /// This represents a line segment\n        /// </summary>\n        private class Edge\n        {\n            public Edge(Point from, Point to)\n            {\n                this.From = from;\n                this.To = to;\n            }\n\n            public readonly Point From;\n            public readonly Point To;\n        }\n\n        #endregion\n\n        /// <summary>\n        /// This clips the subject polygon against the clip polygon (gets the intersection of the two polygons)\n        /// </summary>\n        /// <remarks>\n        /// Based on the psuedocode from:\n        /// http://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman\n        /// </remarks>\n        /// <param name=\"subjectPoly\">Can be concave or convex</param>\n        /// <param name=\"clipPoly\">Must be convex</param>\n        /// <returns>The intersection of the two polygons (or null)</returns>\n        public static Point[] GetIntersectedPolygon(Point[] subjectPoly, Point[] clipPoly)\n        {\n            if (subjectPoly.Length < 3 || clipPoly.Length < 3)\n            {\n                throw new ArgumentException(string.Format(\"The polygons passed in must have at least 3 points: subject={0}, clip={1}\", subjectPoly.Length.ToString(), clipPoly.Length.ToString()));\n            }\n\n            List<Point> outputList = subjectPoly.ToList();\n\n            //\tMake sure it's clockwise\n            if (!IsClockwise(subjectPoly))\n            {\n                outputList.Reverse();\n            }\n\n            //\tWalk around the clip polygon clockwise\n            foreach (Edge clipEdge in IterateEdgesClockwise(clipPoly))\n            {\n                List<Point> inputList = outputList.ToList();\t\t//\tclone it\n                outputList.Clear();\n\n                if (inputList.Count == 0)\n                {\n                    //\tSometimes when the polygons don't intersect, this list goes to zero.  Jump out to avoid an index out of range exception\n                    break;\n                }\n\n                Point S = inputList[inputList.Count - 1];\n\n                foreach (Point E in inputList)\n                {\n                    if (IsInside(clipEdge, E))\n                    {\n                        if (!IsInside(clipEdge, S))\n                        {\n                            Point? point = GetIntersect(S, E, clipEdge.From, clipEdge.To);\n                            if (point == null)\n                            {\n                                throw new ApplicationException(\"Line segments don't intersect\");\t\t//\tmay be colinear, or may be a bug\n                            }\n                            else\n                            {\n                                outputList.Add(point.Value);\n                            }\n                        }\n\n                        outputList.Add(E);\n                    }\n                    else if (IsInside(clipEdge, S))\n                    {\n                        Point? point = GetIntersect(S, E, clipEdge.From, clipEdge.To);\n                        if (point == null)\n                        {\n                            throw new ApplicationException(\"Line segments don't intersect\");\t\t//\tmay be colinear, or may be a bug\n                        }\n                        else\n                        {\n                            outputList.Add(point.Value);\n                        }\n                    }\n\n                    S = E;\n                }\n            }\n\n            //\tExit Function\n            return outputList.ToArray();\n        }\n\n        #region Private Methods\n\n        /// <summary>\n        /// This iterates through the edges of the polygon, always clockwise\n        /// </summary>\n        private static IEnumerable<Edge> IterateEdgesClockwise(Point[] polygon)\n        {\n            if (IsClockwise(polygon))\n            {\n                #region Already clockwise\n\n                for (int cntr = 0; cntr < polygon.Length - 1; cntr++)\n                {\n                    yield return new Edge(polygon[cntr], polygon[cntr + 1]);\n                }\n\n                yield return new Edge(polygon[polygon.Length - 1], polygon[0]);\n\n                #endregion\n            }\n            else\n            {\n                #region Reverse\n\n                for (int cntr = polygon.Length - 1; cntr > 0; cntr--)\n                {\n                    yield return new Edge(polygon[cntr], polygon[cntr - 1]);\n                }\n\n                yield return new Edge(polygon[0], polygon[polygon.Length - 1]);\n\n                #endregion\n            }\n        }\n\n        /// <summary>\n        /// Returns the intersection of the two lines (line segments are passed in, but they are treated like infinite lines)\n        /// </summary>\n        /// <remarks>\n        /// Got this here:\n        /// http://stackoverflow.com/questions/14480124/how-do-i-detect-triangle-and-rectangle-intersection\n        /// </remarks>\n        private static Point? GetIntersect(Point line1From, Point line1To, Point line2From, Point line2To)\n        {\n            Vector direction1 = line1To - line1From;\n            Vector direction2 = line2To - line2From;\n            double dotPerp = (direction1.X * direction2.Y) - (direction1.Y * direction2.X);\n\n            // If it's 0, it means the lines are parallel so have infinite intersection points\n            if (IsNearZero(dotPerp))\n            {\n                return null;\n            }\n\n            Vector c = line2From - line1From;\n            double t = (c.X * direction2.Y - c.Y * direction2.X) / dotPerp;\n            //if (t < 0 || t > 1)\n            //{\n            //    return null;\t\t//\tlies outside the line segment\n            //}\n\n            //double u = (c.X * direction1.Y - c.Y * direction1.X) / dotPerp;\n            //if (u < 0 || u > 1)\n            //{\n            //    return null;\t\t//\tlies outside the line segment\n            //}\n\n            //\tReturn the intersection point\n            return line1From + (t * direction1);\n        }\n\n        private static bool IsInside(Edge edge, Point test)\n        {\n            bool? isLeft = IsLeftOf(edge, test);\n            if (isLeft == null)\n            {\n                //\tColinear points should be considered inside\n                return true;\n            }\n\n            return !isLeft.Value;\n        }\n        private static bool IsClockwise(Point[] polygon)\n        {\n            for (int cntr = 2; cntr < polygon.Length; cntr++)\n            {\n                bool? isLeft = IsLeftOf(new Edge(polygon[0], polygon[1]), polygon[cntr]);\n                if (isLeft != null)\t\t//\tsome of the points may be colinear.  That's ok as long as the overall is a polygon\n                {\n                    return !isLeft.Value;\n                }\n            }\n\n            throw new ArgumentException(\"All the points in the polygon are colinear\");\n        }\n\n        /// <summary>\n        /// Tells if the test point lies on the left side of the edge line\n        /// </summary>\n        private static bool? IsLeftOf(Edge edge, Point test)\n        {\n            Vector tmp1 = edge.To - edge.From;\n            Vector tmp2 = test - edge.To;\n\n            double x = (tmp1.X * tmp2.Y) - (tmp1.Y * tmp2.X);\t\t//\tdot product of perpendicular?\n\n            if (x < 0)\n            {\n                return false;\n            }\n            else if (x > 0)\n            {\n                return true;\n            }\n            else\n            {\n                //\tColinear points;\n                return null;\n            }\n        }\n\n        private static bool IsNearZero(double testValue)\n        {\n            return Math.Abs(testValue) <= .000000001d;\n        }\n\n        #endregion\n    }\n}\n"}
{"func": "using System;\nusing System.Dynamic;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string varname = Console.ReadLine();\n        //Let's pretend the user has entered \"foo\"\n        dynamic expando = new ExpandoObject();\n        var map = expando as IDictionary<string, object>;\n        map.Add(varname, \"Hello world!\");\n\n        Console.WriteLine(expando.foo);\n    }\n}\n"}
{"func": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace RosettaCode\n{\n  internal sealed class Program\n  {\n    private static void Worker(object arg, int id)\n    {\n      var sem = arg as SemaphoreSlim;\n      sem.Wait();\n      Console.WriteLine(\"Thread {0} has a semaphore & is now working.\", id);\n      Thread.Sleep(2*1000);\n      Console.WriteLine(\"#{0} done.\", id);\n      sem.Release();\n    }\n\n    private static void Main()\n    {\n      var semaphore = new SemaphoreSlim(Environment.ProcessorCount*2, int.MaxValue);\n\n      Console.WriteLine(\"You have {0} processors availiabe\", Environment.ProcessorCount);\n      Console.WriteLine(\"This program will use {0} semaphores.\\n\", semaphore.CurrentCount);\n\n      Parallel.For(0, Environment.ProcessorCount*3, y => Worker(semaphore, y));\n    }\n  }\n}\n"}
{"func": "using System;\nusing System.Text;\nusing System.Xml;\n\nnamespace N\n{\n\tpublic class T\n\t{\n\t\tpublic static void Main()\n\t\t{\n\t\t\tvar headers = new [] { \"\", \"X\", \"Y\", \"Z\" };\n\t\t\t\n\t\t\tvar cols = headers.Select(name =>\n\t\t\t\tnew XElement(\n\t\t\t\t\t\"th\",\n\t\t\t\t\tname,\n\t\t\t\t\tnew XAttribute(\"text-align\", \"center\")\n\t\t\t\t)\n\t\t\t);\n\t\t\n\t\t\tvar rows = Enumerable.Range(0, 4).Select(ri =>\n\t\t\t\tnew XElement(\n\t\t\t\t\t\"tr\",\n\t\t\t\t\tnew XElement(\"td\", ri),\n\t\t\t\t\tEnumerable.Range(0, 4).Select(ci =>\n\t\t\t\t\t\tnew XElement(\n\t\t\t\t\t\t\t\"td\",\n\t\t\t\t\t\t\tci,\n\t\t\t\t\t\t\tnew XAttribute(\"text-align\", \"center\")\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t\t\t\n\t\t\tvar xml = new XElement(\n\t\t\t\t\"table\",\n\t\t\t\tnew XElement(\n\t\t\t\t\t\"thead\",\n\t\t\t\t\tnew XElement(\"tr\",    cols),\n\t\t\t\t\tnew XElement(\"tbody\", rows)\n\t\t\t\t)\n\t\t\t);\n\t\t\t\n\t\t\tConsole.WriteLine(xml.ToString());\n\t\t}\n\t}\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RockPaperScissors\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // There is no limit on the amount of weapons supported by RPSGame. Matchups are calculated depending on the order.\n            var rps = new RPSGame(\"scissors\", \"paper\", \"rock\", \"lizard\", \"spock\");\n\n            int wins = 0, losses = 0, draws = 0;\n\n            while (true)\n            {\n                Console.WriteLine(\"Make your move: \" + string.Join(\", \", rps.Weapons) + \", quit\");\n\n                string weapon = Console.ReadLine().Trim().ToLower();\n\n                if (weapon == \"quit\")\n                    break;\n\n                if (!rps.Weapons.Contains(weapon))\n                {\n                    Console.WriteLine(\"Invalid weapon!\");\n                    continue;\n                }\n\n                int result = rps.Next(weapon);\n\n                Console.WriteLine(\"You chose {0} and your opponent chose {1}!\", weapon, rps.LastAIWeapon);\n\n                switch (result)\n                {\n                    case 1: Console.WriteLine(\"{0} pwns {1}. You're a winner!\", weapon, rps.LastAIWeapon);\n                        wins++;\n                        break;\n                    case 0: Console.WriteLine(\"Draw!\");\n                        draws++;\n                        break;\n                    case -1: Console.WriteLine(\"{0} pwns {1}. You're a loser!\", rps.LastAIWeapon, weapon);\n                        losses++;\n                        break;\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"\\nPlayer Statistics\\nWins: {0}\\nLosses: {1}\\nDraws: {2}\", wins, losses, draws);\n        }\n\n        class RPSGame\n        {\n            public RPSGame(params string[] weapons)\n            {\n                Weapons = weapons;\n\n                // Creates a new AI opponent, and gives it the list of weapons.\n                _rpsAI = new RPSAI(weapons);\n            }\n\n            // Play next turn.\n            public int Next(string weapon)\n            {\n                string aiWeapon = _rpsAI.NextMove(); // Gets the AI opponent's next move.\n                LastAIWeapon = aiWeapon; // Saves the AI opponent's move in a property so the player can see it.\n\n                _rpsAI.AddPlayerMove(weapon); // Let the AI know which weapon the player chose, for future predictions.\n                return GetWinner(Weapons, weapon, aiWeapon); // Returns -1 if AI win, 0 if draw, and 1 if player win.\n            }\n\n            // Returns matchup winner.\n            public static int GetWinner(string[] weapons, string weapon1, string weapon2)\n            {\n                if (weapon1 == weapon2)\n                    return 0; // If weapons are the same, return 0 for draw.\n\n                if (GetVictories(weapons, weapon1).Contains(weapon2))\n                    return 1; // Returns 1 for weapon1 win.\n                else if (GetVictories(weapons, weapon2).Contains(weapon1))\n                    return -1; // Returns -1 for weapon2 win.\n\n                throw new Exception(\"No winner found.\");\n            }\n\n            /*\n             * Return weapons that the provided weapon beats.\n             * The are calculated in the following way:\n             * If the index of the weapon is even, then all even indices less than it,\n             * and all odd indices greater than it, are victories.\n             * One exception is if it is an odd index, and also the last index in the set,\n             * then the first index in the set is a victory.\n             */\n            public static IEnumerable<string> GetVictories(string[] weapons, string weapon)\n            {\n                // Gets index of weapon.\n                int index = Array.IndexOf(weapons, weapon);\n\n                // If weapon is odd and the final index in the set, then return the first item in the set as a victory.\n                if (index % 2 != 0 && index == weapons.Length - 1)\n                    yield return weapons[0];\n\n                for (int i = index - 2; i >= 0; i -= 2)\n                    yield return weapons[i];\n\n                for (int i = index + 1; i < weapons.Length; i += 2)\n                    yield return weapons[i];\n            }\n\n            public string LastAIWeapon\n            {\n                private set;\n                get;\n            }\n\n            public readonly string[] Weapons;\n            private RPSAI _rpsAI;\n\n            class RPSAI\n            {\n                public RPSAI(params string[] weapons)\n                {\n                    _weapons = weapons;\n                    _weaponProbability = new Dictionary<string, int>();\n\n                    // The AI sets the probability for each weapon to be chosen as 1.\n                    foreach (string weapon in weapons)\n                        _weaponProbability.Add(weapon, 1);\n\n                    _random = new Random();\n                }\n\n                // Increases probability of selecting each weapon that beats the provided move.\n                public void AddPlayerMove(string weapon)\n                {\n                    int index = Array.IndexOf(_weapons, weapon);\n\n                    foreach (string winWeapon in _weapons.Except(GetVictories(_weapons, weapon)))\n                        if (winWeapon != weapon)\n                            _weaponProbability[winWeapon]++;\n                }\n\n                // Gets the AI's next move.\n                public string NextMove()\n                {\n                    double r = _random.NextDouble();\n\n                    double divisor = _weaponProbability.Values.Sum();\n\n                    var weightedWeaponRanges = new Dictionary<double, string>();\n\n                    double currentPos = 0.0;\n\n                    // Maps probabilities to ranges between 0.0 and 1.0. Returns weighted random weapon.\n                    foreach (var weapon in _weaponProbability)\n                    {\n                        double weightedRange = weapon.Value / divisor;\n                        if (r <= currentPos + (weapon.Value / divisor))\n                            return weapon.Key;\n                        currentPos += weightedRange;\n                    }\n\n                    throw new Exception(\"Error calculating move.\");\n                }\n\n                Random _random;\n                private readonly string[] _weapons;\n                private Dictionary<string, int> _weaponProbability;\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Concurrent;\nusing System.IO;\n\nnamespace SynchronousConcurrency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            BlockingCollection<string> toWriterTask = new BlockingCollection<string>();\n            BlockingCollection<int> fromWriterTask = new BlockingCollection<int>();\n            Task writer = Task.Factory.StartNew(() => ConsoleWriter(toWriterTask, fromWriterTask));\n            Task reader = Task.Factory.StartNew(() => FileReader(fromWriterTask, toWriterTask));\n            Task.WaitAll(writer, reader);\n        }\n        static void ConsoleWriter(BlockingCollection<string> input, BlockingCollection<int> output)\n        {\n            int nLines = 0;\n            string line;\n            while ((line = input.Take()) != null)\n            {\n                Console.WriteLine(line);\n                ++nLines;\n            }\n            output.Add(nLines);\n        }\n        static void FileReader(BlockingCollection<int> input, BlockingCollection<string> output)\n        {\n            StreamReader file = new StreamReader(\"input.txt\"); // TODO: check exceptions\n            string line;\n            while ((line = file.ReadLine()) != null)\n            {\n                output.Add(line);\n\n            }\n            output.Add(null); // EOF\n            Console.WriteLine(\"line count: \" + input.Take());\n        }\n    }\n}\n"}
{"func": "using System;\n\nstatic class Program {\n    struct RecursiveFunc<F> {\n        public Func<RecursiveFunc<F>, F> o;\n    }\n\n    static Func<A, B> Y<A, B>(Func<Func<A, B>, Func<A, B>> f) {\n        var r = new RecursiveFunc<Func<A, B>> { o = w => f(_0 => w.o(w)(_0)) };\n        return r.o(r);\n    }\n\n    static void Main() {\n        // C# can't infer the type arguments to Y either; either it or f must be explicitly typed.\n        var fac = Y((Func<int, int> f) => _0 => _0 <= 1 ? 1 : _0 * f(_0 - 1));\n        var fib = Y((Func<int, int> f) => _0 => _0 <= 2 ? 1 : f(_0 - 1) + f(_0 - 2));\n\n        Console.WriteLine($\"fac(5) = {fac(5)}\");\n        Console.WriteLine($\"fib(9) = {fib(9)}\");\n    }\n}\n"}
{"func": "using System;\nclass SubStringTestClass\n{\n   public static int CountSubStrings(this string testString, string testSubstring) =>\n       testString?.Split(new [] { testSubstring }, StringSplitOptions.None)?.Length - 1 ?? 0;\n}\n"}
{"func": "using System;\n\nstatic class Program\n{\n    static void Main()\n    {\n        Console.WriteLine(10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1);\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\npublic class KaprekarNumbers {\n\n    /// <summary>\n    /// The entry point of the program, where the program control starts and ends.\n    /// </summary>\n    public static void Main() {\n        int count = 0;\n\n        foreach ( ulong i in _kaprekarGenerator(999999) ) {\n            Console.WriteLine(i);\n            count++;\n        }\n\n        Console.WriteLine(\"There are {0} Kaprekar numbers less than 1000000.\", count);\n    }\n\n    /// <summary>\n    /// Generator function which generates the Kaprekar numbers.\n    /// </summary>\n    /// <returns>The generator.</returns>\n    /// <param name=\"max\">The maximum value of the numbers generated.</param>\n    private static IEnumerable<ulong> _kaprekarGenerator(ulong max) {\n\n        ulong next = 1;\n\n        // 1 is always a Kaprekar number.\n        yield return next;\n\n        for ( next = 2; next <= max; next++ ) {\n\n            ulong square = next * next;\n\n            for ( ulong check = 10; check <= 10000000000000000000; check *= 10 ) {\n                // Check the square against each power of 10 from 10^1 to 10^19 (highest which can be\n                // represented by a ulong)\n\n                // If the power of 10 to be checked against is greater than or equal to the square, stop checking\n                if ( square <= check )\n                    break;\n\n                // Given a power of 10 as 10^n, the remainder when dividing the square number by that power\n                // of 10 is equal to the last n digits of the number (starting from the right) and the\n                // quotient gives the remaining digits.\n                // If the last n digits are all zeroes, then the remainder will be zero, which is not\n                // accepted.\n\n                ulong r = square % check;\n                ulong q = (square - r) / check;\n\n                if ( r != 0 && q + r == next ) {\n                    yield return next;\n                    break;\n                }\n            }\n\n        }\n\n    }\n\n}\n"}
{"func": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\n\n    class Program\n    {\n        private static string ConvertCsvToHtmlTable(string csvText)\n        {\n            //split the CSV, assume no commas or line breaks in text\n            List<List<string>> splitString = new List<List<string>>();\n            List<string> lineSplit = csvText.Split('\\n').ToList();\n            foreach (string line in lineSplit)\n            {\n                splitString.Add(line.Split(',').ToList());\n            }\n\n            //encode text safely, and create table\n            string tableResult = \"<table>\";\n            foreach(List<string> splitLine in splitString)\n            {\n                tableResult += \"<tr>\";\n                foreach(string splitText in splitLine)\n                {\n                    tableResult += \"<td>\" + WebUtility.HtmlEncode(splitText) + \"</td>\";\n                }\n                tableResult += \"</tr>\";\n            }\n            tableResult += \"</table>\";\n            return tableResult;\n        }\n    }\n"}
{"func": "using System;\n\nclass Program\n{\n    static int Call(Func<int, int, int> f, int a, int b)\n    {\n        return f(a, b);\n    }\n\n    static void Main()\n    {\n        int a = 6;\n        int b = 2;\n\n                                                                 // No lengthy delegate keyword.\n        Console.WriteLine(\"f=Add, f({0}, {1}) = {2}\", a, b, Call((int x, int y) => { return x + y; }, a, b));\n\n                                                                 // Parameter types can be inferred.\n        Console.WriteLine(\"f=Mul, f({0}, {1}) = {2}\", a, b, Call((x, y) => { return x * y; }, a, b));\n\n                                                                 // Expression lambdas are even shorter (and are most idiomatic).\n        Console.WriteLine(\"f=Div, f({0}, {1}) = {2}\", a, b, Call((x, y) => x / y, a, b));\n    }\n}\n"}
{"func": "namespace Algorithms\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class TopologicalSorter<ValueType>\n    {\n        private class Relations\n        {\n            public int Dependencies = 0;\n            public HashSet<ValueType> Dependents = new HashSet<ValueType>();\n        }\n\n        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();\n\n        public void Add(ValueType obj)\n        {\n            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n        }\n\n        public void Add(ValueType obj, ValueType dependency)\n        {\n            if (dependency.Equals(obj)) return;\n\n            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());\n\n            var dependents = _map[dependency].Dependents;\n\n            if (!dependents.Contains(obj))\n            {\n                dependents.Add(obj);\n\n                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n\n                ++_map[obj].Dependencies;\n            }\n        }\n\n        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)\n        {\n            foreach (var dependency in dependencies) Add(obj, dependency);\n        }\n\n        public void Add(ValueType obj, params ValueType[] dependencies)\n        {\n            Add(obj, dependencies as IEnumerable<ValueType>);\n        }\n\n        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()\n        {\n            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();\n            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n\n            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));\n\n            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));\n\n            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));\n\n            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);\n        }\n\n        public void Clear()\n        {\n            _map.Clear();\n        }\n    }\n\n}\n\n/*\n\tExample usage with Task object\n*/\n\nnamespace ExampleApplication\n{\n    using Algorithms;\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class Task\n    {\n        public string Message;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Task> tasks = new List<Task>\n            {\n                new Task{ Message = \"A - depends on B and C\" },    //0\n                new Task{ Message = \"B - depends on none\" },       //1\n                new Task{ Message = \"C - depends on D and E\" },    //2\n                new Task{ Message = \"D - depends on none\" },       //3\n                new Task{ Message = \"E - depends on F, G and H\" }, //4\n                new Task{ Message = \"F - depends on I\" },          //5\n                new Task{ Message = \"G - depends on none\" },       //6\n                new Task{ Message = \"H - depends on none\" },       //7\n                new Task{ Message = \"I - depends on none\" },       //8\n            };\n\n            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();\n\n            // now setting relations between them as described above\n            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });\n            //resolver.Add(tasks[1]); // no need for this since the task was already mentioned as a dependency\n            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });\n            //resolver.Add(tasks[3]); // no need for this since the task was already mentioned as a dependency\n            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);\n            resolver.Add(tasks[5], tasks[8]);\n            //resolver.Add(tasks[6]); // no need for this since the task was already mentioned as a dependency\n            //resolver.Add(tasks[7]); // no need for this since the task was already mentioned as a dependency\n\n            //resolver.Add(tasks[3], tasks[0]); // uncomment this line to test cycled dependency\n\n            var result = resolver.Sort();\n            var sorted = result.Item1;\n            var cycled = result.Item2;\n\n            if (!cycled.Any())\n            {\n                foreach (var d in sorted) Console.WriteLine(d.Message);\n            }\n            else\n            {\n                Console.Write(\"Cycled dependencies detected: \");\n\n                foreach (var d in cycled) Console.Write($\"{d.Message[0]} \");\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"exiting...\");\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"func": "using System;\n\nnamespace NonDecimalRadicesOutput\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i < 42; i++)\n            {\n                string binary = Convert.ToString(i, 2);\n                string octal = Convert.ToString(i, 8);\n                string hexadecimal = Convert.ToString(i, 16);\n                Console.WriteLine(string.Format(\"Decimal: {0}, Binary: {1}, Octal: {2}, Hexadecimal: {3}\", i, binary, octal, hexadecimal));\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"func": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        double average = 0;\n\n        double[] numArray = { 1, 2, 3, 4, 5 };\n        average = Average(numArray);\n\n        Console.WriteLine(average); // Output is 3\n\n        // Alternative use\n        average = Average(1, 2, 3, 4, 5);\n\n        Console.WriteLine(average); // Output is still 3\n        Console.ReadLine();\n    }\n\n    static double Average(params double[] nums)\n    {\n        double d = 0;\n\n        foreach (double num in nums)\n            d += num;\n        return d / nums.Length;\n    }\n}\n"}
{"func": "using System;\n\nstatic class Program {\n    interface Function<T, R> {\n        R apply(T t);\n    }\n\n    interface RecursiveFunction<F> : Function<RecursiveFunction<F>, F> {\n    }\n\n    static class Functions {\n        class Function<T, R> : Program.Function<T, R> {\n            readonly Func<T, R> _inner;\n\n            public Function(Func<T, R> inner) => this._inner = inner;\n\n            public R apply(T t) => this._inner(t);\n        }\n\n        class RecursiveFunction<F> : Function<Program.RecursiveFunction<F>, F>, Program.RecursiveFunction<F> {\n            public RecursiveFunction(Func<Program.RecursiveFunction<F>, F> inner) : base(inner) {\n            }\n        }\n\n        public static Program.Function<T, R> Create<T, R>(Func<T, R> inner) => new Function<T, R>(inner);\n        public static Program.RecursiveFunction<F> Create<F>(Func<Program.RecursiveFunction<F>, F> inner) => new RecursiveFunction<F>(inner);\n    }\n\n    static Function<A, B> Y<A, B>(Function<Function<A, B>, Function<A, B>> f) {\n        var r = Functions.Create<Function<A, B>>(w => f.apply(Functions.Create<A, B>(x => w.apply(w).apply(x))));\n        return r.apply(r);\n    }\n\n    static void Main(params String[] arguments) {\n        Function<int, int> fib = Y(Functions.Create<Function<int, int>, Function<int, int>>(f => Functions.Create<int, int>(n =>\n            (n <= 2)\n              ? 1\n              : (f.apply(n - 1) + f.apply(n - 2))))\n        );\n        Function<int, int> fac = Y(Functions.Create<Function<int, int>, Function<int, int>>(f => Functions.Create<int, int>(n =>\n            (n <= 1)\n              ? 1\n              : (n * f.apply(n - 1))))\n        );\n\n        Console.WriteLine(\"fib(10) = \" + fib.apply(10));\n        Console.WriteLine(\"fac(10) = \" + fac.apply(10));\n    }\n}\n"}
{"func": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaCode\n{\n  internal class Program\n  {\n    private static void Main()\n    {\n      var sb = new StringBuilder();\n      string F = \"File.txt\";\n\n      // Read a file, line by line.\n      try\n      {\n        foreach (string readLine in File.ReadLines(F))\n        {\n          // Use the data in some way...\n          sb.Append(readLine);\n          sb.Append(\"\\n\");\n        }\n      }\n      catch (Exception exception)\n      {\n        Console.WriteLine(exception.Message);\n        Environment.Exit(1);\n      }\n\n      // Preset the results\n      Console.WriteLine(sb.ToString());\n    }\n  }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        string infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        Console.WriteLine(infix.ToPostfix());\n    }\n}\n\npublic static class ShuntingYard\n{\n    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators\n        = new (string symbol, int precedence, bool rightAssociative) [] {\n            (\"^\", 4, true),\n            (\"*\", 3, false),\n            (\"/\", 3, false),\n            (\"+\", 2, false),\n            (\"-\", 2, false)\n    }.ToDictionary(op => op.symbol);\n\n    public static string ToPostfix(this string infix) {\n        string[] tokens = infix.Split(' ');\n        var stack = new Stack<string>();\n        var output = new List<string>();\n        foreach (string token in tokens) {\n            if (int.TryParse(token, out _)) {\n                output.Add(token);\n                Print(token);\n            } else if (operators.TryGetValue(token, out var op1)) {\n                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {\n                    int c = op1.precedence.CompareTo(op2.precedence);\n                    if (c < 0 || !op1.rightAssociative && c <= 0) {\n                        output.Add(stack.Pop());\n                    } else {\n                        break;\n                    }\n                }\n                stack.Push(token);\n                Print(token);\n            } else if (token == \"(\") {\n                stack.Push(token);\n                Print(token);\n            } else if (token == \")\") {\n                string top = \"\";\n                while (stack.Count > 0 && (top = stack.Pop()) != \"(\") {\n                    output.Add(top);\n                }\n                if (top != \"(\") throw new ArgumentException(\"No matching left parenthesis.\");\n                Print(token);\n            }\n        }\n        while (stack.Count > 0) {\n            var top = stack.Pop();\n            if (!operators.ContainsKey(top)) throw new ArgumentException(\"No matching right parenthesis.\");\n            output.Add(top);\n        }\n        Print(\"pop\");\n        return string.Join(\" \", output);\n\n        //Yikes!\n        void Print(string action) => Console.WriteLine($\"{action + \":\",-4} {$\"stack[ {string.Join(\" \", stack.Reverse())} ]\",-18} {$\"out[ {string.Join(\" \", output)} ]\"}\");\n        //A little more readable?\n        void Print(string action) => Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {string.Join(\" \", stack.Reverse())} ]\", $\"out[ {string.Join(\" \", output)} ]\");\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Multisplit\n{\n    internal static class Program\n    {\n        private static void Main(string[] args)\n        {\n            foreach (var s in \"a!===b=!=c\".Multisplit(true, \"==\", \"!=\", \"=\")) // Split the string and return the separators.\n            {\n                Console.Write(s); // Write the returned substrings and separators to the console.\n            }\n            Console.WriteLine();\n        }\n\n        private static IEnumerable<string> Multisplit(this string s, bool returnSeparators = false,\n                                                      params string[] delimiters)\n        {\n            var currentString = new StringBuilder(); /* Initiate the StringBuilder. This will hold the current string to return\n                                                      * once we find a separator. */\n\n            int index = 0; // Initiate the index counter at 0. This tells us our current position in the string to read.\n\n            while (index < s.Length) // Loop through the string.\n            {\n                // This will get the highest priority separator found at the current index, or null if there are none.\n                string foundDelimiter =\n                    (from delimiter in delimiters\n                     where s.Length >= index + delimiter.Length &&\n                           s.Substring(index, delimiter.Length) == delimiter\n                     select delimiter).FirstOrDefault();\n\n                if (foundDelimiter != null)\n                {\n                    yield return currentString.ToString(); // Return the current string.\n                    if (returnSeparators) // Return the separator, if the user specified to do so.\n                        yield return\n                            string.Format(\"{{\\\"{0}\\\", ({1}, {2})}}\",\n                                          foundDelimiter,\n                                          index, index + foundDelimiter.Length);\n                    currentString.Clear(); // Clear the current string.\n                    index += foundDelimiter.Length; // Move the index past the current separator.\n                }\n                else\n                {\n                    currentString.Append(s[index++]); // Add the character at this index to the current string.\n                }\n            }\n\n            if (currentString.Length > 0)\n                yield return currentString.ToString(); // If we have anything left over, return it.\n        }\n    }\n}\n"}
{"func": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string testString = \"test\";\n        Console.WriteLine(testString.Substring(1));\n        Console.WriteLine(testString.Substring(0, testString.Length - 1));\n        Console.WriteLine(testString.Substring(1, testString.Length - 2));\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nstatic class Program\n{\n    // In short:\n    public static void Foo()\n    {\n        string s;\n\n        // Assign empty string:\n        s = \"\";\n        // or\n        s = string.Empty;\n\n        // Check for empty string only (false if s is null):\n        if (s != null && s.Length == 0) { }\n\n        // Check for null or empty (more idiomatic in .NET):\n        if (string.IsNullOrEmpty(s)) { }\n    }\n\n    public static void Main()\n    {\n        // Equality is somewhat convoluted in .NET.\n        // The methods above are the author's recommendation for each case.\n\n        // s is initialized to null. It is a variable of the System.String type that is a null reference and is not\n        // the empty string.\n        string s = null;\n\n        // Alias Console.WriteLine(bool) with a shorter name to make the demonstration code less verbose.\n        Action<bool> P = Console.WriteLine;\n\n        // Assign the empty string literal to s.\n        s = \"\";\n\n        // ' Assign String.Empty to s.\n        s = string.Empty;\n\n        // The empty string literal is the same object reference as String.Empty because of string interning, meaning the\n        // behavior of the two is identical.\n        // From this point on, \"\" will be used instead of String.Empty for brevity.\n\n        //#== operator (object)\n        // The == operator tests for reference equality when overload resolution fails to find an operator defined by\n        // either operand type. However, which strings are interned is a CLR implementation detail and may be unreliable\n        // when comparing non-empty strings. The equivalent in VB.NET would be s Is \"\".\n        // Note that there is no such operator as Object.op_Equality(Object, Object): the use of the == operator for\n        // types of type Object is a C# language feature.\n        P((object)s == \"\");\n\n        //#Object.ReferenceEquals(Object, Object)\n        // The previous line is semantically to the following, though it does not involve a method call.\n        P(object.ReferenceEquals(s, \"\"));\n\n        //#String.op_Equality(String, String)\n        // The equality operator of System.String is implemented as a call to String.Equals(String). Operators cannot be\n        // called with method syntax in C#.\n        P(s == \"\");\n\n        //#String.Equals(String, String)\n        // Call the static method defined on the String type, which first calls Object.ReferenceEquals and then, after\n        // verifying that both are strings of the same length, compares the strings character-by-character.\n        P(string.Equals(s, \"\"));\n\n        //#Object.Equals(Object, Object)\n        // First checks for reference equality and whether one or both of the arguments is null. It then invokes the\n        // instance Equals method of the left parameter.\n        P(object.Equals(s, \"\"));\n\n        //#String.Equals(String)\n        // The method is called with the string literal as the receiver because a NullReferenceException is thrown if s\n        // is null.\n        P(\"\".Equals(s));\n\n        //#String.Length\n        // Check the Length property. The ?. (null-conditional) operator is used to avoid NullReferenceException. The Equals\n        // call above can also be done this way. Null propagation makes the equality operator return false if one operand\n        // is a Nullable<T> and does not have a value, making this result in false when s is null.\n        P(s?.Length == 0);\n\n        //#String.Length\n        // A more traditional version of the null-conditional using a guard clause.\n        // Both the null-conditional and this are noticeably (~4 times) faster than \"\".Equals(s). In general, it appears that\n        // for empty strings, using the length is faster than using an equality comparison.\n        P(s != null && s.Length == 0);\n\n        //#String.IsNullOrEmpty(String)\n        // Note that all of the other methods give false for null.\n        // A static method of System.String that returns true if the string is null or its length is zero.\n        P(string.IsNullOrEmpty(s));\n\n        //#System.Collections.Generic.EqualityComparer(Of String).Default.Equals(String, String)\n        // The EqualityComparer(Of T) class provides default implementations when an IEqualityComparer(Of T) is required.\n        // The implementation for String calls String.Equals(String).\n        P(EqualityComparer<string>.Default.Equals(s, \"\"));\n\n        Console.WriteLine();\n\n        // Each of the means described above, except testing for a non-empty string.\n        P((object)s != \"\");\n        P(!object.ReferenceEquals(s, \"\"));\n        P(s != \"\");\n        P(!string.Equals(s, \"\"));\n        P(!object.Equals(s, \"\"));\n        P(!\"\".Equals(s));\n        P(s?.Length != 0); // Still false when s is null!\n        P(s == null || s.Length != 0);\n        P(!string.IsNullOrEmpty(s));\n        P(!EqualityComparer<string>.Default.Equals(s, \"\"));\n    }\n}\n"}
{"func": "using System;\nusing System.Reflection;\n\npublic class MyClass\n{\n    private int answer = 42;\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var myInstance = new MyClass();\n        var fieldInfo = typeof(MyClass).GetField(\"answer\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var answer = fieldInfo.GetValue(myInstance);\n        Console.WriteLine(answer);\n    }\n}\n"}
{"func": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Test\n{\n    public static void Main()\n    {\n        var list = new List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };\n        list.SortSublist(6, 1, 7);\n        Console.WriteLine(string.Join(\", \", list));\n    }\n}\n\npublic static class Extensions\n{\n    public static void SortSublist<T>(this List<T> list, params int[] indices)\n        where T : IComparable<T>\n    {\n        var sublist = indices.OrderBy(i => i)\n            .Zip(indices.Select(i => list[i]).OrderBy(v => v),\n                (Index, Value) => new { Index, Value });\n\n        foreach (var entry in sublist) {\n            list[entry.Index] = entry.Value;\n        }\n    }\n\n}\n"}
{"func": "using System;\n\nnamespace PrependString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"World\";\n            str = \"Hello \" + str;\n            Console.WriteLine(str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"func": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.IO;\n\nnamespace Pig {\n\n\tclass Roll {\n\t\tpublic int TotalScore{get;set;}\n\t\tpublic int RollScore{get;set;}\n\t\tpublic bool Continue{get;set;}\n\t}\n\n\tclass Player {\n\t\tpublic String Name{get;set;}\n\t\tpublic int Score {get;set;}\n\t\tRandom rand;\n\n\t\tpublic Player() {\n\t\t\tScore = 0;\n\t\t\trand = new Random();\n\t\t}\n\n\t\tpublic Roll Roll(int LastScore){\n\t\t\tRoll roll = new Roll();\n\t\t\troll.RollScore = rand.Next(6) + 1;\n\n\t\t\tif(roll.RollScore == 1){\n\t\t\t\troll.TotalScore = 0;\n\t\t\t\troll.Continue = false;\n\t\t\t\treturn roll;\n\t\t\t}\n\n\t\t\troll.TotalScore = LastScore + roll.RollScore;\n\t\t\troll.Continue = true;\n\t\t\treturn roll;\n\t\t}\n\n\t\tpublic void FinalizeTurn(Roll roll){\n\t\t\tScore = Score + roll.TotalScore;\n\t\t}\n\t}\n\n\tpublic class Game {\t\t\n\t\tpublic static void Main(String[] argv){\n\t\t\tString input = null;\n\t\t\tPlayer[] players = new Player[2];\n\n\t\t\t// Game loop\n\t\t\twhile(true){\t\t\t\t\t\t\t\t\n\t\t\t\tConsole.Write(\"Greetings! Would you like to play a game (y/n)?\");\n\t\t\t\twhile(input == null){\n\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\tif(input.ToLowerInvariant() == \"y\"){\n\t\t\t\t\t\tplayers[0] = new Player();\n\t\t\t\t\t\tplayers[1] = new Player();\n\t\t\t\t\t\tConsole.Write(\"Player One, what's your name?\");\n\t\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\t\tplayers[0].Name = input;\n\t\t\t\t\t\tConsole.Write(\"Player Two, what's your name?\");\n\t\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\t\tplayers[1].Name = input;\n\t\t\t\t\t\tConsole.WriteLine(players[0].Name + \" and \" + players[1].Name + \", prepare to do battle!\");\n\t\t\t\t\t} else if (input.ToLowerInvariant() == \"n\"){\n\t\t\t\t\t\tgoto Goodbye; /* Not considered harmful */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinput = null;\n\t\t\t\t\t\tConsole.Write(\"I'm sorry, I don't understand. Play a game (y/n)?\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Play the game\n\t\t\t\tint currentPlayer = 0;\n\t\t\t\tRoll roll = null;\n\t\t\t\tbool runTurn = true;\n\t\t\t\twhile(runTurn){\n\t\t\t\t\tPlayer p = players[currentPlayer];\n\t\t\t\t\troll = p.Roll( (roll !=null) ? roll.TotalScore : 0 );\n\t\t\t\t\tif(roll.Continue){\n\t\t\t\t\t\tif(roll.TotalScore + p.Score > 99){\n\t\t\t\t\t\t\tConsole.WriteLine(\"Congratulations, \" + p.Name + \"! You rolled a \" + roll.RollScore + \" for a final score of \" + (roll.TotalScore + p.Score) + \"!\");\n\t\t\t\t\t\t\trunTurn = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write(p.Name + \": Roll \" + roll.RollScore + \"/Turn \" + roll.TotalScore + \"/Total \" + (roll.TotalScore + p.Score) + \". Roll again (y/n)?\");\n\t\t\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\t\t\tif(input.ToLowerInvariant() == \"y\"){\n\t\t\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t\t\t} else if (input.ToLowerInvariant() == \"n\"){\n\t\t\t\t\t\t\t\tp.FinalizeTurn(roll);\n\t\t\t\t\t\t\t\tcurrentPlayer = Math.Abs(currentPlayer - 1);\t\t\t\n\t\t\t\t\t\t\t\tConsole.WriteLine();\n\t\t\t\t\t\t\tConsole.WriteLine(players[0].Name + \": \" + players[0].Score + \"    \" + players[1].Name + \": \" + players[1].Score);\t\t\t\t\t\n\t\t\t\t\t\t\t\tConsole.WriteLine(players[currentPlayer].Name + \", your turn begins.\");\n\t\t\t\t\t\t\t\troll = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinput = null;\n\t\t\t\t\t\t\t\tConsole.Write(\"I'm sorry, I don't understand. Play a game (y/n)?\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.WriteLine(p.Name + @\", you rolled a 1 and lost your points for this turn.\nYour current score:\t\" + p.Score);\n\t\t\t\t\t\tConsole.WriteLine();\n\t\t\t\t\t\tConsole.WriteLine(players[0].Name + \": \" + players[0].Score + \"    \" + players[1].Name + \": \" + players[1].Score);\n\t\t\t\t\t\tcurrentPlayer = Math.Abs(currentPlayer - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tinput = null;\n\t\t\t}\n\t\t\tGoodbye:\n\t\t\tConsole.WriteLine(\"Thanks for playing, and remember: the house ALWAYS wins!\");\n\t\t\tSystem.Environment.Exit(0);\n\t\t}\n\t}\n}\n"}
{"func": "using System;\nusing System.IO;\nusing System.Linq;\n\npublic class Rosetta\n{\n    public static void Main() => RemoveLines(\"foobar.txt\", start: 1, count: 2);\n\n    static void RemoveLines(string filename, int start, int count = 1) =>\n        File.WriteAllLines(filename, File.ReadAllLines(filename)\n            .Where((line, index) => index < start - 1 || index >= start + count - 1));\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Node\n{\n    int Value;\n    Node Left;\n    Node Right;\n\n    Node(int value = default(int), Node left = default(Node), Node right = default(Node))\n    {\n        Value = value;\n        Left = left;\n        Right = right;\n    }\n\n    IEnumerable<int> Preorder()\n    {\n        yield return Value;\n        if (Left != null)\n            foreach (var value in Left.Preorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Preorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Inorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Inorder())\n                yield return value;\n        yield return Value;\n        if (Right != null)\n            foreach (var value in Right.Inorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Postorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Postorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Postorder())\n                yield return value;\n        yield return Value;\n    }\n\n    IEnumerable<int> LevelOrder()\n    {\n        var queue = new Queue<Node>();\n        queue.Enqueue(this);\n        while (queue.Any())\n        {\n            var node = queue.Dequeue();\n            yield return node.Value;\n            if (node.Left != null)\n                queue.Enqueue(node.Left);\n            if (node.Right != null)\n                queue.Enqueue(node.Right);\n        }\n    }\n\n    static void Main()\n    {\n        var tree = new Node(1, new Node(2, new Node(4, new Node(7)), new Node(5)), new Node(3, new Node(6, new Node(8), new Node(9))));\n        foreach (var traversal in new Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })\n            Console.WriteLine(\"{0}:\\t{1}\", traversal.Method.Name, string.Join(\" \", traversal()));\n    }\n}\n"}
{"func": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main()\n        {\n            double n;\n\n            //If the current door number is the perfect square of an integer, say it is open, else say it is closed.\n            for (int d = 1; d <= 100; d++)\n                Console.WriteLine(\"Door #{0}: {1}\", d, (n = Math.Sqrt(d)) == (int)n ? \"Open\" : \"Closed\");\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"func": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Encode(\"http://foo bar/\"));\n        }\n\n        private static string Encode(string uri)\n        {\n            return Uri.EscapeDataString(uri);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main( string[] args )\n    {\n        foreach ( string dir in args )\n        {\n            Console.WriteLine( \"'{0}' {1} empty\", dir, IsDirectoryEmpty( dir ) ? \"is\" : \"is not\" );\n        }\n    }\n\n    private static bool IsDirectoryEmpty( string dir )\n    {\n        return ( Directory.GetFiles( dir ).Length == 0 &&\n            Directory.GetDirectories( dir ).Length == 0 );\n    }\n}\n"}
{"func": "using System;\nnamespace Entropy\n{\n\t class Program\n\t{\n\t\tpublic static double logtwo(double num)\n\t\t{\n\t\t\treturn Math.Log(num)/Math.Log(2);\n\t\t}\n\t\tstatic double Contain(string x,char k)\n\t\t{\n\t\t\tdouble count=0;\n\t\t\tforeach (char Y in x)\n\t\t\t{\n\t\t\t\tif(Y.Equals(k))\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\tlabel1:\n\t\t\tstring input = Console.ReadLine();\n\t\t\tdouble infoC=0;\n\t\t\tdouble freq;\n\t\t\tstring k=\"\";\n\t\t\tforeach (char c1 in input)\n\t\t\t{\n\t\t\t\tif (!(k.Contains(c1.ToString())))\n\t\t\t\t\tk+=c1;\n\t\t\t}\n\t\t\tforeach (char c in k)\n\t\t\t{\n\t\t\t\tfreq=Contain(input,c)/(double)input.Length;\n\t\t\t\tinfoC+=freq*logtwo(freq);\n\t\t\t}\n\t\t\tinfoC/=-1;\n\t\t\tConsole.WriteLine(\"The Entropy of {0} is {1}\",input,infoC);\n\t\t\tgoto label1;\n\n\t\t}\n\t}\n}\n"}
{"func": "using System;\n\nclass GuessTheNumberGame\n{\n    static void Main()\n    {\n        bool numberCorrect = false;\n        Random randomNumberGenerator = new Random();\n        int randomNumber = randomNumberGenerator.Next(1, 10+1);\n\n        Console.WriteLine(\"I'm thinking of a number between 1 and 10.  Can you guess it?\");\n        do\n        {\n            Console.Write(\"Guess: \");\n            int userGuess = int.Parse(Console.ReadLine());\n\n            if (userGuess == randomNumber)\n            {\n                numberCorrect = true;\n                Console.WriteLine(\"Congrats!!  You guessed right!\");\n            }\n            else\n                Console.WriteLine(\"That's not it.  Guess again.\");\n        } while (!numberCorrect);\n    }\n};\n"}
{"func": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint q = 929;\n\t\t\tif ( !isPrime(q) ) return;\n\t\t\tint r = q;\n\t\t\twhile( r > 0 )\n\t\t\t\tr <<= 1;\n\t\t\tint d = 2 * q + 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tint i = 1;\n\t\t\t\tfor( int p=r; p!=0; p<<=1 )\n\t\t\t\t{\n\t\t\t\t\ti = (i*i) % d;\n\t\t\t\t\tif (p < 0) i *= 2;\n\t\t\t\t\tif (i > d) i -= d;\n\t\t\t\t}\n\t\t\t\tif (i != 1) d += 2 * q; else break;\t\t\t\t\n\t\t\t}\n\t\t\twhile(true);\n\t\t\t\n\t\t\tConsole.WriteLine(\"2^\"+q+\"-1 = 0 (mod \"+d+\")\");\n\t\t}\n\t\t\n\t\tstatic bool isPrime(int n)\n\t\t{\n\t\t\tif ( n % 2 == 0 ) return n == 2;\n\t\t\tif ( n % 3 == 0 ) return n == 3;\n\t\t\tint d = 5;\n\t\t\twhile( d*d <= n )\n\t\t\t{\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 2;\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 4;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n}\n"}
{"func": "using System;\nusing System.Text.RegularExpressions;\n\nprivate static string RegexRemoveCharactersFromString(string testString, string removeChars)\n{\n    string pattern = \"[\" + removeChars + \"]\";\n    return Regex.Replace(testString, pattern, \"\");\n}\n"}
{"func": "using System;\nusing System.ComponentModel;\nusing System.Windows.Forms;\n\nclass RosettaInteractionForm : Form\n{\n\n    // Model used for DataBinding.\n    // Notifies bound controls about Value changes.\n    class NumberModel: INotifyPropertyChanged\n    {\n        // initialize event with empty delegate to avoid checks on null\n        public event PropertyChangedEventHandler PropertyChanged = delegate {};\n\n        int _value;\n        public int Value\n        {\n            get { return _value; }\n            set\n            {\n                _value = value;\n                // Notify bound control about value change\n                PropertyChanged(this, new PropertyChangedEventArgs(\"Value\"));\n            }\n        }\n    }\n\n    NumberModel model = new NumberModel{ Value = 0};\n\n    RosettaInteractionForm()\n    {\n        //MaskedTextBox is a TextBox variety with built-in input validation\n        var tbNumber = new MaskedTextBox\n                        {\n                            Mask=\"0000\",            // allow 4 decimal digits only\n                            ResetOnSpace = false,   // don't enter spaces\n                            Dock = DockStyle.Top    // place at the top of form\n                        };\n        // bound TextBox.Text to NumberModel.Value;\n        tbNumber.DataBindings.Add(\"Text\", model, \"Value\");\n        var enabledIfZero = new Binding(\"Enabled\", model, \"Value\");\n        EnableControlWhen(tbNumber, value => value == 0);\n\n        var btIncrement = new Button{Text = \"Increment\", Dock = DockStyle.Bottom};\n        btIncrement.Click += delegate\n                        {\n                            model.Value++;\n                        };\n        EnableControlWhen(btIncrement, value => value < 10);\n        var btDecrement = new Button{Text = \"Decrement\", Dock = DockStyle.Bottom};\n        btDecrement.Click += delegate\n                        {\n                            model.Value--;\n                        };\n        EnableControlWhen(btDecrement, value => value > 0);\n        Controls.Add(tbNumber);\n        Controls.Add(btIncrement);\n        Controls.Add(btDecrement);\n    }\n\n    // common part of creating bindings for Enabled property\n    void EnableControlWhen(Control ctrl, Func<int, bool> predicate)\n    {\n        // bind Control.Enabled to NumberModel.Value\n        var enabledBinding = new Binding(\"Enabled\", model, \"Value\");\n        // Format event is called when model value should be converted to Control value.\n        enabledBinding.Format += (sender, args) =>\n            {\n                // Enabled property is of bool type.\n                if (args.DesiredType != typeof(bool)) return;\n                // set resulting value by applying condition\n                args.Value = predicate((int)args.Value);\n            };\n        // as a result, control will be enabled if predicate returns true\n        ctrl.DataBindings.Add(enabledBinding);\n    }\n\n    static void Main()\n    {\n        Application.Run(new RosettaInteractionForm());\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Xml.Linq;\n\nclass Program\n{\n    static string CreateXML(Dictionary<string, string> characterRemarks)\n    {\n        var remarks = characterRemarks.Select(r => new XElement(\"Character\", r.Value, new XAttribute(\"Name\", r.Key)));\n        var xml = new XElement(\"CharacterRemarks\", remarks);\n        return xml.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        var characterRemarks = new Dictionary<string, string>\n        {\n            { \"April\", \"Bubbly: I'm > Tam and <= Emily\" },\n            { \"Tam O'Shanter\", \"Burns: \\\"When chapman billies leave the street ...\\\"\" },\n            { \"Emily\", \"Short & shrift\" }\n        };\n\n        string xml = CreateXML(characterRemarks);\n        Console.WriteLine(xml);\n    }\n}\n"}
{"func": "using System;\n\nstatic class Program\n{\n    static void Main(string[] args)\n    {\n        Quaternion q = new Quaternion(1, 2, 3, 4);\n        Quaternion q1 = new Quaternion(2, 3, 4, 5);\n        Quaternion q2 = new Quaternion(3, 4, 5, 6);\n        double r = 7;\n\n        Console.WriteLine(\"q = {0}\", q);\n        Console.WriteLine(\"q1 = {0}\", q1);\n        Console.WriteLine(\"q2 = {0}\", q2);\n        Console.WriteLine(\"r = {0}\", r);\n\n        Console.WriteLine(\"q.Norm() = {0}\", q.Norm());\n        Console.WriteLine(\"q1.Norm() = {0}\", q1.Norm());\n        Console.WriteLine(\"q2.Norm() = {0}\", q2.Norm());\n\n        Console.WriteLine(\"-q = {0}\", -q);\n        Console.WriteLine(\"q.Conjugate() = {0}\", q.Conjugate());\n\n        Console.WriteLine(\"q + r = {0}\", q + r);\n        Console.WriteLine(\"q1 + q2 = {0}\", q1 + q2);\n        Console.WriteLine(\"q2 + q1 = {0}\", q2 + q1);\n\n        Console.WriteLine(\"q * r = {0}\", q * r);\n        Console.WriteLine(\"q1 * q2 = {0}\", q1 * q2);\n        Console.WriteLine(\"q2 * q1 = {0}\", q2 * q1);\n\n        Console.WriteLine(\"q1*q2 {0} q2*q1\", (q1 * q2) == (q2 * q1) ? \"==\" : \"!=\");\n    }\n}\n"}
{"func": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            //Close all doors to start.\n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            //For each pass...\n            for (int p = 0; p < 100; p++)//number of passes\n            {\n                //For each door to toggle...\n                for (int d = 0; d < 100; d++)//door number\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            //Output the results.\n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"func": "using System;\n\nclass JensensDevice\n{\n    public static double Sum(ref int i, int lo, int hi, Func<double> term)\n    {\n        double temp = 0.0;\n        for (i = lo; i <= hi; i++)\n        {\n            temp += term();\n        }\n        return temp;\n    }\n\n    static void Main()\n    {\n        int i = 0;\n        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));\n    }\n}\n"}
{"func": "using Func = System.Func<int, int>;\nusing FuncFunc = System.Func<System.Func<int, int>, System.Func<int, int>>;\n\nstatic class Program {\n    struct RecursiveFunc<F> {\n        public System.Func<RecursiveFunc<F>, F> o;\n    }\n\n    static System.Func<A, B> Y<A, B>(System.Func<System.Func<A, B>, System.Func<A, B>> f) {\n        var r = new RecursiveFunc<System.Func<A, B>>() {\n            o = new System.Func<RecursiveFunc<System.Func<A, B>>, System.Func<A, B>>((RecursiveFunc<System.Func<A, B>> w) => {\n                return f(new System.Func<A, B>((A x) => {\n                    return w.o(w)(x);\n                }));\n            })\n        };\n        return r.o(r);\n    }\n\n    static FuncFunc almost_fac = (Func f) => {\n        return new Func((int n) => {\n            if (n <= 1) return 1;\n            return n * f(n - 1);\n        });\n    };\n\n    static FuncFunc almost_fib = (Func f) => {\n        return new Func((int n) => {\n            if (n <= 2) return 1;\n            return f(n - 1) + f(n - 2);\n        });\n    };\n\n    static int Main() {\n        var fib = Y(almost_fib);\n        var fac = Y(almost_fac);\n        System.Console.WriteLine(\"fib(10) = \" + fib(10));\n        System.Console.WriteLine(\"fac(10) = \" + fac(10));\n        return 0;\n    }\n}\n"}
{"func": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string testString = \"She was a soul stripper. She took my heart!\";\n        string removeChars = \"aei\";\n        Console.WriteLine(RemoveCharactersFromString(testString, removeChars));\n    }\n}\n"}
{"func": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(\"First 25 ludic numbers:\");\n        Console.WriteLine(string.Join(\", \", LudicNumbers(150).Take(25)));\n        Console.WriteLine();\n\n        Console.WriteLine($\"There are {LudicNumbers(1001).Count()} ludic numbers below 1000\");\n        Console.WriteLine();\n\n        foreach (var ludic in LudicNumbers(22000).Skip(1999).Take(6)\n                .Select((n, i) => $\"#{i+2000} = {n}\")) {\n            Console.WriteLine(ludic);\n        }\n        Console.WriteLine();\n\n        Console.WriteLine(\"Triplets below 250:\");\n        var queue = new Queue<int>(5);\n        foreach (int x in LudicNumbers(255)) {\n            if (queue.Count == 5) queue.Dequeue();\n            queue.Enqueue(x);\n            if (x - 6 < 250 && queue.Contains(x - 6) && queue.Contains(x - 4)) {\n                Console.WriteLine($\"{x-6}, {x-4}, {x}\");\n            }\n        }\n    }\n\n    public static IEnumerable<int> LudicNumbers(int limit) {\n        yield return 1;\n        //Like a linked list, but with value types.\n        //Create 2 extra entries at the start to avoid ugly index calculations\n        //and another at the end to avoid checking for index-out-of-bounds.\n        Entry[] values = Enumerable.Range(0, limit + 1).Select(n => new Entry(n)).ToArray();\n        for (int i = 2; i < limit; i = values[i].Next) {\n            yield return values[i].N;\n            int start = i;\n            while (start < limit) {\n                Unlink(values, start);\n                for (int step = 0; step < i && start < limit; step++)\n                    start = values[start].Next;\n            }\n        }\n    }\n\n    static void Unlink(Entry[] values, int index) {\n        values[values[index].Prev].Next = values[index].Next;\n        values[values[index].Next].Prev = values[index].Prev;\n    }\n\n}\n\nstruct Entry\n{\n    public Entry(int n) : this() {\n        N = n;\n        Prev = n - 1;\n        Next = n + 1;\n    }\n\n    public int N { get; }\n    public int Prev { get; set; }\n    public int Next { get; set; }\n}\n"}
{"func": "using System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n"}
{"func": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA256\n{\n    [TestClass]\n    public class SHA256ManagedTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var buffer = Encoding.UTF8.GetBytes(\"Rosetta code\");\n            var hashAlgorithm = new SHA256Managed();\n            var hash = hashAlgorithm.ComputeHash(buffer);\n            Assert.AreEqual(\n                \"76-4F-AF-5C-61-AC-31-5F-14-97-F9-DF-A5-42-71-39-65-B7-85-E5-CC-2F-70-7D-64-68-D7-D1-12-4C-DF-CF\",\n                BitConverter.ToString(hash));\n        }\n    }\n}\n"}
{"func": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        //other puzzle types elided\n        knightMoves = {(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2)};\n\n    private (int dx, int dy)[] moves;\n\n    public static void Main()\n    {\n        var knightSolver = new Solver(knightMoves);\n        Print(knightSolver.Solve(true,\n            \".000....\",\n            \".0.00...\",\n            \".0000000\",\n            \"000..0.0\",\n            \"0.0..000\",\n            \"1000000.\",\n            \"..00.0..\",\n            \"...000..\"));\n\n        Print(knightSolver.Solve(true,\n            \".....0.0.....\",\n            \".....0.0.....\",\n            \"....00000....\",\n            \".....000.....\",\n            \"..0..0.0..0..\",\n            \"00000...00000\",\n            \"..00.....00..\",\n            \"00000...00000\",\n            \"..0..0.0..0..\",\n            \".....000.....\",\n            \"....00000....\",\n            \".....0.0.....\",\n            \".....0.0.....\"\n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"func": "using System;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nclass YahooSearch {\n    private string query;\n    private string content;\n    private int page;\n\n    const string yahoo = \"http://search.yahoo.com/search?\";\n\n    public YahooSearch(string query) : this(query, 0) { }\n\n    public YahooSearch(string query, int page) {\n        this.query = query;\n        this.page = page;\n        this.content = new WebClient()\n            .DownloadString(\n                string.Format(yahoo + \"p={0}&b={1}\", query, this.page * 10 + 1)\n            );\n    }\n\n    public YahooResult[] Results {\n        get {\n            List<YahooResult> results = new List<YahooResult>();\n\n            Func<string, string, string> substringBefore = (str, before) =>\n            {\n                int iHref = str.IndexOf(before);\n                return iHref < 0 ? \"\" : str.Substring(0, iHref);\n            };\n            Func<string, string, string> substringAfter = (str, after) =>\n            {\n                int iHref = str.IndexOf(after);\n                return iHref < 0 ? \"\" : str.Substring(iHref + after.Length);\n            };\n            Converter<string, string> getText = p =>\n                Regex.Replace(p, \"<[^>]*>\", x => \"\");\n\n            Regex rx = new Regex(@\"\n                <li>\n                    <div \\s class=\"\"res\"\">\n                        <div>\n                            <h3>\n                                <a \\s (?'LinkAttributes'[^>]+)>\n                                    (?'LinkText' .*?)\n                                (?></a>)\n                            </h3>\n                        </div>\n                        <div \\s class=\"\"abstr\"\">\n                            (?'Abstract' .*?)\n                        (?></div>)\n                        .*?\n                    (?></div>)\n                </li>\",\n                RegexOptions.IgnorePatternWhitespace\n                | RegexOptions.ExplicitCapture\n            );\n            foreach (Match e in rx.Matches(this.content)) {\n                string rurl = getText(substringBefore(substringAfter(\n                    e.Groups[\"LinkAttributes\"].Value, @\"href=\"\"\"), @\"\"\"\"));\n                string rtitle = getText(e.Groups[\"LinkText\"].Value);\n                string rcontent = getText(e.Groups[\"Abstract\"].Value);\n\n                results.Add(new YahooResult(rurl, rtitle, rcontent));\n            }\n            return results.ToArray();\n        }\n    }\n\n    public YahooSearch NextPage() {\n        return new YahooSearch(this.query, this.page + 1);\n    }\n\n    public YahooSearch GetPage(int page) {\n        return new YahooSearch(this.query, page);\n    }\n}\n\nclass YahooResult {\n    public string URL { get; set; }\n    public string Title { get; set; }\n    public string Content { get; set; }\n\n    public YahooResult(string url, string title, string content) {\n        this.URL = url;\n        this.Title = title;\n        this.Content = content;\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"\\nTitle: {0}\\nLink:  {1}\\nText:  {2}\",\n            Title, URL, Content);\n    }\n}\n\n// Usage:\n\nclass Prog {\n    static void Main() {\n        foreach (int page in new[] { 0, 1 })\n        {\n            YahooSearch x = new YahooSearch(\"test\", page);\n\n            foreach (YahooResult result in x.Results)\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading; //Remember to add this if you want the game to pause in RealisticGuess.Start()\n\nnamespace ConsoleApplication1\n{\n    class RealisticGuess //Simulates a guessing game between two people. Guessing efficiency is not a goal.\n    {\n        private int max;\n        private int min;\n        private int guess;\n\n        public void Start()\n        {\n            Console.Clear();\n            string input;\n\n            try\n            {\n                Console.WriteLine(\"Please enter the lower boundary\");\n                input = Console.ReadLine();\n                min = Convert.ToInt32(input);\n                Console.WriteLine(\"Please enter the upper boundary\");\n                input = Console.ReadLine();\n                max = Convert.ToInt32(input);\n            }\n            catch (FormatException)\n            {\n                Console.WriteLine(\"The entry you have made is invalid. Please make sure your entry is an integer and try again.\");\n                Console.ReadKey(true);\n                Start();\n            }\n            Console.WriteLine(\"Think of a number between {0} and {1}.\", min, max);\n            Thread.Sleep(2500);\n            Console.WriteLine(\"Ready?\");\n            Console.WriteLine(\"Press any key to begin.\");\n            Console.ReadKey(true);\n            Guess(min, max);\n        }\n        public void Guess(int min, int max)\n        {\n            int counter = 1;\n            string userAnswer;\n            bool correct = false;\n            Random rand = new Random();\n\n            while (correct == false)\n            {\n                guess = rand.Next(min, max);\n                Console.Clear();\n                Console.WriteLine(\"{0}\", guess);\n                Console.WriteLine(\"Is this number correct? {Y/N}\");\n                userAnswer = Console.ReadLine();\n                if (userAnswer != \"y\" && userAnswer != \"Y\" && userAnswer != \"n\" && userAnswer != \"N\")\n                {\n                    Console.WriteLine(\"Your entry is invalid. Please enter either 'Y' or 'N'\");\n                    Console.WriteLine(\"Is the number correct? {Y/N}\");\n                    userAnswer = Console.ReadLine();\n                }\n                if (userAnswer == \"y\" || userAnswer == \"Y\")\n                {\n                    correct = true;\n                }\n                if (userAnswer == \"n\" || userAnswer == \"N\")\n                {\n                    counter++;\n                    if (max == min)\n                    {\n                        Console.WriteLine(\"Error: Range Intersect. Press enter to restart the game.\");  //This message should never pop up if the user enters good data.\n                        Console.ReadKey(true);                                                          //It handles the game-breaking exception that occurs\n                        Guess(1, 101);                                                                  //when the max guess number is the same as the min number.\n                    }\n                    Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                    userAnswer = Console.ReadLine();\n                    if (userAnswer != \"l\" && userAnswer != \"L\" && userAnswer != \"h\" && userAnswer != \"H\")\n                    {\n                        Console.WriteLine(\"Your entry is invalid. Please enter either 'L' or 'H'\");\n                        Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                        userAnswer = Console.ReadLine();\n                    }\n                    if (userAnswer == \"l\" || userAnswer == \"L\")\n                    {\n                        max = guess;\n                    }\n                    if (userAnswer == \"h\" || userAnswer == \"H\")\n                    {\n                        min = guess;\n                    }\n                }\n            }\n            if (correct == true)\n            {\n                EndAndLoop(counter);\n            }\n        }\n\n        public void EndAndLoop(int iterations)\n        {\n            string userChoice;\n            bool loop = false;\n            Console.WriteLine(\"Game over. It took {0} guesses to find the number.\", iterations);\n            while (loop == false)\n            {\n                Console.WriteLine(\"Would you like to play again? {Y/N}\");\n                userChoice = Console.ReadLine();\n                if (userChoice != \"Y\" && userChoice != \"y\" && userChoice != \"N\" && userChoice != \"n\")\n                {\n                    Console.WriteLine(\"Sorry, your input is invalid. Please answer 'Y' to play again, or 'N' to quit.\");\n                }\n                if (userChoice == \"Y\" || userChoice == \"y\")\n                {\n                    Start();\n                }\n                if (userChoice == \"N\" || userChoice == \"n\")\n                {\n                    Environment.Exit(1);\n                }\n            }\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Title = \"Random Number\";\n            RealisticGuess game = new RealisticGuess();\n            game.Start();\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    public static void Main() {\n        var sequence = new[] { \"A\", \"B\", \"C\", \"D\" };\n        foreach (var subset in Subsets(sequence.Length).Where(s => !IsContinuous(s))) {\n            Console.WriteLine(string.Join(\" \", subset.Select(i => sequence[i])));\n        }\n    }\n\n    static IEnumerable<List<int>> Subsets(int length) {\n        int[] values = Enumerable.Range(0, length).ToArray();\n        var stack = new Stack<int>(length);\n        for (int i = 0; stack.Count > 0 || i < length; ) {\n            if (i < length) {\n                stack.Push(i++);\n                yield return (from index in stack.Reverse() select values[index]).ToList();\n            } else {\n                i = stack.Pop() + 1;\n                if (stack.Count > 0) i = stack.Pop() + 1;\n            }\n        }\n    }\n\n    static bool IsContinuous(List<int> list) => list[list.Count - 1] - list[0] + 1 == list.Count;\n\n}\n"}
{"func": "using System;\nusing System.Linq;\nnamespace ConsoleApplication\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //Reverse() is an extension method on IEnumerable<char>.\n            //The constructor takes a char[], so we have to call ToArray()\n            Func<string, string> reverse = s => new string(s.Reverse().ToArray());\n\n            string phrase = \"rosetta code phrase reversal\";\n            //Reverse the string\n            Console.WriteLine(reverse(phrase));\n            //Reverse each individual word in the string, maintaining original string order.\n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Select(word => reverse(word))));\n            //Reverse the order of each word of the phrase, maintaining the order of characters in each word.\n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Reverse()));\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static void Main() {\n        Func<int, IEnumerable<int>> ms = m => Infinite().Select(i => (int)Math.Pow(i, m));\n        var squares = ms(2);\n        var cubes = ms(3);\n        var filtered = squares.Where(square => cubes.First(cube => cube >= square) != square);\n        var final = filtered.Skip(20).Take(10);\n        foreach (var i in final) Console.WriteLine(i);\n    }\n\n    static IEnumerable<int> Infinite() {\n        var i = 0;\n        while (true) yield return i++;\n    }\n}\n"}
{"func": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace History\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var h = new HistoryObject();\n            h.Value = 5;\n            h.Value = \"foo\";\n            h.Value += \"bar\";\n\n            var history = h.ToArray();\n\n            for (int i = 0; i < history.Length; i++)\n            {\n                Console.Write(\"{0}{1}\", history[i], ((i >= history.Length - 1) ? \"\\n\" : \" <- \"));\n            }\n\n            h.Undo();\n            h.Undo();\n            h.Undo();\n\n            Console.WriteLine(h.Value);\n        }\n\n        private class HistoryObject : IEnumerable<object>\n        {\n            public HistoryObject()\n            {\n                _history = new Stack<object>(); // Initiates the history stack.\n            }\n\n            public object Value\n            {\n                get // Returns the top value from the history if there is one. Otherwise null.\n                {\n                    if (_history.Count > 0)\n                        return _history.Peek();\n                    return null;\n                }\n                set { _history.Push(value); } // Adds the specified value to the history.\n            }\n\n            public void Undo()\n            {\n                if (_history.Count > 0)\n                    _history.Pop(); // Removes the current value from the history.\n            }\n\n            // History stack that will hold all previous values of the object.\n            private readonly Stack<object> _history;\n\n            public IEnumerator<object> GetEnumerator()\n            {\n                return _history.GetEnumerator();\n            }\n\n            IEnumerator IEnumerable.GetEnumerator()\n            {\n                return GetEnumerator();\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nstatic class Program\n{\n    static void Main()\n    {\n        using (var f = new Form() { FormBorderStyle = FormBorderStyle.None, WindowState = FormWindowState.Maximized })\n        {\n            f.Show();\n            Console.WriteLine($\"Size of maximized borderless form:  {f.Width}x{f.Height}\");\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.AmicablePairs\n{\n    internal static class Program {\n        private const int Limit = 20000;\n\n        private static void Main()\n        {\n            foreach (var pair in GetPairs(Limit))\n            {\n                Console.WriteLine(\"{0} {1}\", pair.Item1, pair.Item2);\n            }\n        }\n\n        private static IEnumerable<Tuple<int, int>> GetPairs(int max)\n        {\n            List<int> divsums =\n                Enumerable.Range(0, max + 1).Select(i => ProperDivisors(i).Sum()).ToList();\n            for(int i=1; i<divsums.Count; i++) {\n                int sum = divsums[i];\n                if(i < sum && sum <= divsums.Count && divsums[sum] == i) {\n                    yield return new Tuple<int, int>(i, sum);\n                }\n            }\n        }\n\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n    }\n}\n"}
{"func": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.Write(@\"\nmultiline\nstrings are easy\nto put together\nin C#\");\n    }\n}\n"}
{"func": "using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing RosettaCode.SetOfRealNumbers;\n\nnamespace RosettaCode.SetOfRealNumbersTest\n{\n    [TestClass]\n    public class SetTest\n    {\n        [TestMethod]\n        public void TestUnion()\n        {\n            var set =\n                new Set<double>(value => 0d < value && value <= 1d).Union(\n                    new Set<double>(value => 0d <= value && value < 2d));\n            Assert.IsTrue(set.Contains(0d));\n            Assert.IsTrue(set.Contains(1d));\n            Assert.IsFalse(set.Contains(2d));\n        }\n\n        [TestMethod]\n        public void TestIntersection()\n        {\n            var set =\n                new Set<double>(value => 0d <= value && value < 2d).Intersection(\n                    new Set<double>(value => 1d < value && value <= 2d));\n            Assert.IsFalse(set.Contains(0d));\n            Assert.IsFalse(set.Contains(1d));\n            Assert.IsFalse(set.Contains(2d));\n        }\n\n        [TestMethod]\n        public void TestDifference()\n        {\n            var set =\n                new Set<double>(value => 0d <= value && value < 3d).Difference(\n                    new Set<double>(value => 0d < value && value < 1d));\n            Assert.IsTrue(set.Contains(0d));\n            Assert.IsTrue(set.Contains(1d));\n            Assert.IsTrue(set.Contains(2d));\n\n            set =\n                new Set<double>(value => 0d <= value && value < 3d).Difference(\n                    new Set<double>(value => 0d <= value && value <= 1d));\n            Assert.IsFalse(set.Contains(0d));\n            Assert.IsFalse(set.Contains(1d));\n            Assert.IsTrue(set.Contains(2d));\n        }\n    }\n}\n"}
{"func": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tclass MyClass : ICloneable\n\t\t{\n\t\t\tpublic MyClass() { f = new int[3]{2,3,5}; c = '1'; }\n\t\t\t\n\t\t\tpublic object Clone()\n\t\t\t{\t\t\t\t\n\t\t\t\tMyClass cpy = (MyClass) this.MemberwiseClone();\n\t\t\t\tcpy.f = (int[]) this.f.Clone();\t\t\t\n\t\t\t\treturn cpy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic char c;\n\t\t\tpublic int[] f;\n\t\t}\n\t\t\n\t\tpublic static void Main( string[] args )\n\t\t{\n\t\t\tMyClass c1 = new MyClass();\n\t\t\tMyClass c2 = (MyClass) c1.Clone();\n\t\t}\n\t}\n}\n"}
{"func": "using System;\nusing System.Numerics;\n\nnamespace agm\n{\n    class Program\n    {\n        static BigInteger BIP(char leadDig, int numDigs)\n        {\n            return BigInteger.Parse(leadDig + new string('0', numDigs));\n        }\n\n        static BigInteger IntSqRoot(BigInteger v)\n        {\n            int digs = Math.Max(0, v.ToString().Length / 2);\n            BigInteger res = BIP('3', digs), term;\n            while (true) {\n                term = v / res; if (Math.Abs((double)(term - res)) < 2) break;\n                res = (res + term) / 2; } return res;\n        }\n\n        static BigInteger CalcByAGM(int digits)\n        {\n            int digs = digits + (int)(Math.Log(digits) / 2), d2 = digs * 2;\n            BigInteger a = BIP('1', digs),              // initial value = 1\n                       b = IntSqRoot(BIP('5', d2 - 1)), // initial value = square root of 0.5\n                       c;\n            while (true) {\n                c = a; a = ((a + b) / 2); b = IntSqRoot(c * b);\n                if (Math.Abs((double)(a - b)) <= 1) break;\n            }\n            return b;\n        }\n\n        static void Main(string[] args)\n        {\n            int digits = 25000;\n            if (args.Length > 0)\n            {\n                int.TryParse(args[0], out digits);\n                if (digits < 1 || digits > 999999) digits = 25000;\n            }\n            Console.WriteLine(\"0.{0}\", CalcByAGM(digits).ToString());\n            if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n        }\n    }\n}\n"}
{"func": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string dog = \"Benjamin\";\n        string Dog = \"Samba\";\n        string DOG = \"Bernie\";\n        Console.WriteLine(string.Format(\"The three dogs are named {0}, {1}, and {2}.\", dog, Dog, DOG));\n    }\n}\n"}
{"func": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        //other puzzle types elided\n        numbrixMoves = {(1,0),(0,1),(-1,0),(0,-1)};\n\n    private (int dx, int dy)[] moves;\n\n    public static void Main()\n    {\n        var numbrixSolver = new Solver(numbrixMoves);\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0,  0, 46, 45,  0, 55, 74,  0,  0 },\n            {  0, 38,  0,  0, 43,  0,  0, 78,  0 },\n            {  0, 35,  0,  0,  0,  0,  0, 71,  0 },\n            {  0,  0, 33,  0,  0,  0, 59,  0,  0 },\n            {  0, 17,  0,  0,  0,  0,  0, 67,  0 },\n            {  0, 18,  0,  0, 11,  0,  0, 64,  0 },\n            {  0,  0, 24, 21,  0,  1,  2,  0,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0, 11, 12, 15, 18, 21, 62, 61,  0 },\n            {  0,  6,  0,  0,  0,  0,  0, 60,  0 },\n            {  0, 33,  0,  0,  0,  0,  0, 57,  0 },\n            {  0, 32,  0,  0,  0,  0,  0, 56,  0 },\n            {  0, 37,  0,  1,  0,  0,  0, 73,  0 },\n            {  0, 38,  0,  0,  0,  0,  0, 72,  0 },\n            {  0, 43, 44, 47, 48, 51, 76, 77,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"func": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"func": "using System;\n\npublic static class DiscordianDate\n{\n    static readonly string[] seasons = { \"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\" };\n    static readonly string[] weekdays = { \"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\" };\n    static readonly string[] apostles = { \"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\" };\n    static readonly string[] holidays = { \"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\" };\n\n    public static string Discordian(this DateTime date) {\n        string yold = $\" in the YOLD {date.Year + 1166}.\";\n        int dayOfYear = date.DayOfYear;\n\n        if (DateTime.IsLeapYear(date.Year)) {\n            if (dayOfYear == 60) return \"St. Tib's day\" + yold;\n            else if (dayOfYear > 60) dayOfYear--;\n        }\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        int seasonNr = dayOfYear / 73;\n        int weekdayNr = dayOfYear % 5;\n        string holyday = \"\";\n\n        if (seasonDay == 5)       holyday = $\" Celebrate {apostles[seasonNr]}!\";\n        else if (seasonDay == 50) holyday = $\" Celebrate {holidays[seasonNr]}!\";\n        return $\"{weekdays[weekdayNr]}, day {seasonDay} of {seasons[seasonNr]}{yold}{holyday}\";\n    }\n\n    public static void Main() {\n        foreach (var (day, month, year) in new [] {\n            (1, 1, 2010),\n            (5, 1, 2010),\n            (19, 2, 2011),\n            (28, 2, 2012),\n            (29, 2, 2012),\n            (1, 3, 2012),\n            (19, 3, 2013),\n            (3, 5, 2014),\n            (31, 5, 2015),\n            (22, 6, 2016),\n            (15, 7, 2016),\n            (12, 8, 2017),\n            (19, 9, 2018),\n            (26, 9, 2018),\n            (24, 10, 2019),\n            (8, 12, 2020),\n            (31, 12, 2020)\n        })\n        {\n            Console.WriteLine($\"{day:00}-{month:00}-{year:00} = {new DateTime(year, month, day).Discordian()}\");\n        }\n    }\n\n}\n"}
{"func": "using System;\n\nstatic class YCombinator<T, TResult>\n{\n    // RecursiveFunc is not needed to call Fix() and so can be private.\n    private delegate Func<T, TResult> RecursiveFunc(RecursiveFunc r);\n\n    public static Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>> Fix { get; } =\n        f => ((RecursiveFunc)(g => f(x => g(g)(x))))(g => f(x => g(g)(x)));\n}\n\nstatic class Program\n{\n    static void Main()\n    {\n        var fac = YCombinator<int, int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));\n        var fib = YCombinator<int, int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));\n\n        Console.WriteLine(fac(10));\n        Console.WriteLine(fib(10));\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"func": "using System;\n\npublic class Gray {\n    public static ulong grayEncode(ulong n) {\n        return n^(n>>1);\n    }\n\n    public static ulong grayDecode(ulong n) {\n        ulong i=1<<8*64-2; //long is 64-bit\n        ulong p, b=p=n&i;\n\n        while((i>>=1)>0)\n            b|=p=n&i^p>>1;\n        return b;\n    }\n\n    public static void Main(string[] args) {\n        Console.WriteLine(\"Number\\tBinary\\tGray\\tDecoded\");\n        for(ulong i=0;i<32;i++) {\n            Console.WriteLine(string.Format(\"{0}\\t{1}\\t{2}\\t{3}\", i, Convert.ToString((long)i, 2), Convert.ToString((long)grayEncode(i), 2), grayDecode(grayEncode(i))));\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Numerics;\n\nstatic int g = 7;\nstatic double[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n\t     771.32342877765313, -176.61502916214059, 12.507343278686905,\n\t     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};\n\t\t\nComplex Gamma(Complex z)\n{\n    // Reflection formula\n    if (z.Real < 0.5)\n\t{\n        return Math.PI / (Complex.Sin( Math.PI * z) * Gamma(1 - z));\n\t}\n    else\n\t{\n        z -= 1;\n        Complex x = p[0];\n        for (var i = 1; i < g + 2; i++)\n\t\t{\n            x += p[i]/(z+i);\n\t\t}\n        Complex t = z + g + 0.5;\n        return Complex.Sqrt(2 * Math.PI) * (Complex.Pow(t, z + 0.5)) * Complex.Exp(-t) * x;\n\t}\n}\n"}
{"func": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main()\n        {\n            double n;\n\n            //If the current door number is the perfect square of an integer, say it is open, else say it is closed.\n            for (int d = 1; d <= 100; d++)\n                Console.WriteLine(\"Door #{0}: {1}\", d, (n = Math.Sqrt(d)) == (int)n ? \"Open\" : \"Closed\");\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class SetConsolidation\n{\n    public static void Main()\n    {\n        var setCollection1 = new[] {new[] {\"A\", \"B\"}, new[] {\"C\", \"D\"}};\n        var setCollection2 = new[] {new[] {\"A\", \"B\"}, new[] {\"B\", \"D\"}};\n        var setCollection3 = new[] {new[] {\"A\", \"B\"}, new[] {\"C\", \"D\"}, new[] {\"B\", \"D\"}};\n        var setCollection4 = new[] {new[] {\"H\", \"I\", \"K\"}, new[] {\"A\", \"B\"}, new[] {\"C\", \"D\"},\n            new[] {\"D\", \"B\"}, new[] {\"F\", \"G\", \"H\"}};\n        var input = new[] {setCollection1, setCollection2, setCollection3, setCollection4};\n\n        foreach (var sets in input) {\n            Console.WriteLine(\"Start sets:\");\n            Console.WriteLine(string.Join(\", \", sets.Select(s => \"{\" + string.Join(\", \", s) + \"}\")));\n            Console.WriteLine(\"Sets consolidated using Nodes:\");\n            Console.WriteLine(string.Join(\", \", ConsolidateSets1(sets).Select(s => \"{\" + string.Join(\", \", s) + \"}\")));\n            Console.WriteLine(\"Sets consolidated using Set operations:\");\n            Console.WriteLine(string.Join(\", \", ConsolidateSets2(sets).Select(s => \"{\" + string.Join(\", \", s) + \"}\")));\n            Console.WriteLine();\n        }\n    }\n\n    /// <summary>\n    /// Consolidates sets using a connected-component-finding-algorithm involving Nodes with parent pointers.\n    /// The more efficient solution, but more elaborate code.\n    /// </summary>\n    private static IEnumerable<IEnumerable<T>> ConsolidateSets1<T>(IEnumerable<IEnumerable<T>> sets,\n        IEqualityComparer<T> comparer = null)\n    {\n        if (comparer == null) comparer = EqualityComparer<T>.Default;\n        var elements = new Dictionary<T, Node<T>>();\n        foreach (var set in sets) {\n            Node<T> top = null;\n            foreach (T value in set) {\n                Node<T> element;\n                if (elements.TryGetValue(value, out element)) {\n                    if (top != null) {\n                        var newTop = element.FindTop();\n                        top.Parent = newTop;\n                        element.Parent = newTop;\n                        top = newTop;\n                    } else {\n                        top = element.FindTop();\n                    }\n                } else {\n                    elements.Add(value, element = new Node<T>(value));\n                    if (top == null) top = element;\n                    else element.Parent = top;\n                }\n            }\n        }\n        foreach (var g in elements.Values.GroupBy(element => element.FindTop().Value))\n            yield return g.Select(e => e.Value);\n    }\n\n    private class Node<T>\n    {\n        public Node(T value, Node<T> parent = null) {\n            Value = value;\n            Parent = parent ?? this;\n        }\n\n        public T Value { get; }\n        public Node<T> Parent { get; set; }\n\n        public Node<T> FindTop() {\n            var top = this;\n            while (top != top.Parent) top = top.Parent;\n            //Set all parents to the top element to prevent repeated iteration in the future\n            var element = this;\n            while (element.Parent != top) {\n                var parent = element.Parent;\n                element.Parent = top;\n                element = parent;\n            }\n            return top;\n        }\n    }\n\n    /// <summary>\n    /// Consolidates sets using operations on the HashSet&lt;T&gt; class.\n    /// Less efficient than the other method, but easier to write.\n    /// </summary>\n    private static IEnumerable<IEnumerable<T>> ConsolidateSets2<T>(IEnumerable<IEnumerable<T>> sets,\n        IEqualityComparer<T> comparer = null)\n    {\n        if (comparer == null) comparer = EqualityComparer<T>.Default;\n        var currentSets = sets.Select(s => new HashSet<T>(s)).ToList();\n        int previousSize;\n        do {\n            previousSize = currentSets.Count;\n            for (int i = 0; i < currentSets.Count - 1; i++) {\n                for (int j = currentSets.Count - 1; j > i; j--) {\n                    if (currentSets[i].Overlaps(currentSets[j])) {\n                        currentSets[i].UnionWith(currentSets[j]);\n                        currentSets.RemoveAt(j);\n                    }\n                }\n            }\n        } while (previousSize > currentSets.Count);\n        foreach (var set in currentSets) yield return set.Select(value => value);\n    }\n}\n"}
{"func": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"func": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass CSharpPendulum\n{\n    Form _form;\n    Timer _timer;\n\n    double _angle = Math.PI / 2,\n           _angleAccel,\n           _angleVelocity = 0,\n           _dt = 0.1;\n\n    int _length = 50;\n\n    [STAThread]\n    static void Main()\n    {\n        var p = new CSharpPendulum();\n    }\n\n    public CSharpPendulum()\n    {\n        _form = new Form() { Text = \"Pendulum\", Width = 200, Height = 200 };\n        _timer = new Timer() { Interval = 30 };\n\n        _timer.Tick += delegate(object sender, EventArgs e)\n        {\n            int anchorX = (_form.Width / 2) - 12,\n                anchorY = _form.Height / 4,\n                ballX = anchorX + (int)(Math.Sin(_angle) * _length),\n                ballY = anchorY + (int)(Math.Cos(_angle) * _length);\n\n            _angleAccel = -9.81 / _length * Math.Sin(_angle);\n            _angleVelocity += _angleAccel * _dt;\n            _angle += _angleVelocity * _dt;\n\n            Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);\n            Graphics g = Graphics.FromImage(dblBuffer);\n            Graphics f = Graphics.FromHwnd(_form.Handle);\n\n            g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));\n            g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);\n            g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);\n\n            f.Clear(Color.White);\n            f.DrawImage(dblBuffer, new Point(0, 0));\n        };\n\n        _timer.Start();\n        Application.Run(_form);\n    }\n}\n"}
{"func": "using System;\n\npublic class SevenSidedDice\n{\n    Random random = new Random();\n\t\t\n        static void Main(string[] args)\n\t\t{\n\t\t\tSevenSidedDice sevenDice = new SevenSidedDice();\n\t\t\tConsole.WriteLine(\"Random number from 1 to 7: \"+ sevenDice.seven());\n            Console.Read();\n\t\t}\n\t\t\n\t\tint seven()\n\t\t{\n\t\t\tint v=21;\n\t\t\twhile(v>20)\n\t\t\t\tv=five()+five()*5-6;\n\t\t\treturn 1+v%7;\n\t\t}\n\t\t\n\t\tint five()\n\t\t{\n        return 1 + random.Next(5);\n\t\t}\n}\n"}
{"func": "using System;\n\nusing FuncFunc = System.Func<System.Func<int, int>, System.Func<int, int>>;\n\nstatic class Program {\n    struct RecursiveFunc<F> {\n        public Func<RecursiveFunc<F>, F> o;\n    }\n\n    static Func<A, B> Y<A, B>(Func<Func<A, B>, Func<A, B>> f) {\n        var r = new RecursiveFunc<Func<A, B>> {\n            o = w => f(x => w.o(w)(x))\n        };\n        return r.o(r);\n    }\n\n    static FuncFunc almost_fac = f => n => n <= 1 ? 1 : n * f(n - 1);\n\n    static FuncFunc almost_fib = f => n => n <= 2 ? 1 : f(n - 1) + f(n - 2);\n\n    static void Main() {\n        var fib = Y(almost_fib);\n        var fac = Y(almost_fac);\n        Console.WriteLine(\"fib(10) = \" + fib(10));\n        Console.WriteLine(\"fac(10) = \" + fac(10));\n    }\n}\n"}
{"func": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace VanDerCorput\n{\n    /// <summary>\n    /// Computes the Van der Corput sequence for any number base.\n    /// The numbers in the sequence vary from zero to one, including zero but excluding one.\n    /// The sequence possesses low discrepancy.\n    /// Here are the first ten terms for bases 2 to 5:\n    ///\n    /// base 2:  0  1/2  1/4  3/4  1/8  5/8  3/8  7/8  1/16  9/16\n    /// base 3:  0  1/3  2/3  1/9  4/9  7/9  2/9  5/9  8/9  1/27\n    /// base 4:  0  1/4  1/2  3/4  1/16  5/16  9/16  13/16  1/8  3/8\n    /// base 5:  0  1/5  2/5  3/5  4/5  1/25  6/25  11/25  16/25  21/25\n    /// </summary>\n    /// <see cref=\"http://rosettacode.org/wiki/Van_der_Corput_sequence\"/>\n    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>\n    {\n        /// <summary>\n        /// Number base for the sequence, which must bwe two or more.\n        /// </summary>\n        public int Base { get; private set; }\n\n        /// <summary>\n        /// Maximum number of terms to be returned by iterator.\n        /// </summary>\n        public long Count { get; private set; }\n\n        /// <summary>\n        /// Construct a sequence for the given base.\n        /// </summary>\n        /// <param name=\"iBase\">Number base for the sequence.</param>\n        /// <param name=\"count\">Maximum number of items to be returned by the iterator.</param>\n        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {\n            if (iBase < 2)\n                throw new ArgumentOutOfRangeException(\"iBase\", \"must be two or greater, not the given value of \" + iBase);\n            Base = iBase;\n            Count = count;\n        }\n\n        /// <summary>\n        /// Compute nth term in the Van der Corput sequence for the base specified in the constructor.\n        /// </summary>\n        /// <param name=\"n\">The position in the sequence, which may be zero or any positive number.</param>\n        /// This number is always an integral power of the base.</param>\n        /// <returns>The Van der Corput sequence value expressed as a Tuple containing a numerator and a denominator.</returns>\n        public Tuple<long,long> Compute(long n)\n        {\n            long p = 0, q = 1;\n            long numerator, denominator;\n            while (n != 0)\n            {\n                p = p * Base + (n % Base);\n                q *= Base;\n                n /= Base;\n            }\n            numerator = p;\n            denominator = q;\n            while (p != 0)\n            {\n                n = p;\n                p = q % p;\n                q = n;\n            }\n            numerator /= q;\n            denominator /= q;\n            return new Tuple<long,long>(numerator, denominator);\n        }\n\n        /// <summary>\n        /// Compute nth term in the Van der Corput sequence for the given base.\n        /// </summary>\n        /// <param name=\"iBase\">Base to use for the sequence.</param>\n        /// <param name=\"n\">The position in the sequence, which may be zero or any positive number.</param>\n        /// <returns>The Van der Corput sequence value expressed as a Tuple containing a numerator and a denominator.</returns>\n        public static Tuple<long, long> Compute(int iBase, long n)\n        {\n            var seq = new VanDerCorputSequence(iBase);\n            return seq.Compute(n);\n        }\n\n        /// <summary>\n        /// Iterate over the Van Der Corput sequence.\n        /// The first value in the sequence is always zero, regardless of the base.\n        /// </summary>\n        /// <returns>A tuple whose items are the Van der Corput value given as a numerator and denominator.</returns>\n        public IEnumerator<Tuple<long, long>> GetEnumerator()\n        {\n            long iSequenceIndex = 0L;\n            while (iSequenceIndex < Count)\n            {\n                yield return Compute(iSequenceIndex);\n                iSequenceIndex++;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestBasesTwoThroughFive();\n\n            Console.WriteLine(\"Type return to continue...\");\n            Console.ReadLine();\n        }\n\n        static void TestBasesTwoThroughFive()\n        {\n            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) // Just the first 10 elements of the each sequence\n            {\n                Console.Write(\"base \" + seq.Base + \":\");\n                foreach(var vc in seq)\n                    Console.Write(\" \" + vc.Item1 + \"/\" + vc.Item2);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"func": "using System;\n\npublic class IntegerOverflow\n{\n    public static void Main() {\n        unchecked {\n            Console.WriteLine(\"For 32-bit signed integers:\");\n            Console.WriteLine(-(-2147483647 - 1));\n            Console.WriteLine(2000000000 + 2000000000);\n            Console.WriteLine(-2147483647 - 2147483647);\n            Console.WriteLine(46341 * 46341);\n            Console.WriteLine((-2147483647 - 1) / -1);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 64-bit signed integers:\");\n            Console.WriteLine(-(-9223372036854775807L - 1));\n            Console.WriteLine(5000000000000000000L + 5000000000000000000L);\n            Console.WriteLine(-9223372036854775807L - 9223372036854775807L);\n            Console.WriteLine(3037000500L * 3037000500L);\n            Console.WriteLine((-9223372036854775807L - 1) / -1);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 32-bit unsigned integers:\");\n            //Negating a 32-bit unsigned integer will convert it to a signed 64-bit integer.\n            Console.WriteLine(-4294967295U);\n            Console.WriteLine(3000000000U + 3000000000U);\n            Console.WriteLine(2147483647U - 4294967295U);\n            Console.WriteLine(65537U * 65537U);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 64-bit unsigned integers:\");\n            // The - operator cannot be applied to 64-bit unsigned integers; it will always give a compile-time error.\n            //Console.WriteLine(-18446744073709551615UL);\n            Console.WriteLine(10000000000000000000UL + 10000000000000000000UL);\n            Console.WriteLine(9223372036854775807UL - 18446744073709551615UL);\n            Console.WriteLine(4294967296UL * 4294967296UL);\n            Console.WriteLine();\n        }\n\n        int i = 2147483647;\n        Console.WriteLine(i + 1);\n        try {\n            checked { Console.WriteLine(i + 1); }\n        } catch (OverflowException) {\n            Console.WriteLine(\"Overflow!\");\n        }\n    }\n\n}\n"}
{"func": "using System;\nusing System.Globalization;\n\nstruct LimitedInt : IComparable, IComparable<LimitedInt>, IConvertible, IEquatable<LimitedInt>, IFormattable\n{\n    const int MIN_VALUE = 1;\n    const int MAX_VALUE = 10;\n\n    public static readonly LimitedInt MinValue = new LimitedInt(MIN_VALUE);\n    public static readonly LimitedInt MaxValue = new LimitedInt(MAX_VALUE);\n\n    static bool IsValidValue(int value) => value >= MIN_VALUE && value <= MAX_VALUE;\n\n    readonly int _value;\n    public int Value => this._value == 0 ? MIN_VALUE : this._value; // Treat the default, 0, as being the minimum value.\n\n    public LimitedInt(int value)\n    {\n        if (!IsValidValue(value))\n            throw new ArgumentOutOfRangeException(nameof(value), value, $\"Value must be between {MIN_VALUE} and {MAX_VALUE}.\");\n        this._value = value;\n    }\n\n    #region IComparable\n    public int CompareTo(object obj)\n    {\n        if (obj is LimitedInt l) return this.Value.CompareTo(l);\n        throw new ArgumentException(\"Object must be of type \" + nameof(LimitedInt), nameof(obj));\n    }\n    #endregion\n\n    #region IComparable<LimitedInt>\n    public int CompareTo(LimitedInt other) => this.Value.CompareTo(other.Value);\n    #endregion\n\n    #region IConvertible\n    public TypeCode GetTypeCode() => this.Value.GetTypeCode();\n    bool IConvertible.ToBoolean(IFormatProvider provider) => ((IConvertible)this.Value).ToBoolean(provider);\n    byte IConvertible.ToByte(IFormatProvider provider) => ((IConvertible)this.Value).ToByte(provider);\n    char IConvertible.ToChar(IFormatProvider provider) => ((IConvertible)this.Value).ToChar(provider);\n    DateTime IConvertible.ToDateTime(IFormatProvider provider) => ((IConvertible)this.Value).ToDateTime(provider);\n    decimal IConvertible.ToDecimal(IFormatProvider provider) => ((IConvertible)this.Value).ToDecimal(provider);\n    double IConvertible.ToDouble(IFormatProvider provider) => ((IConvertible)this.Value).ToDouble(provider);\n    short IConvertible.ToInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToInt16(provider);\n    int IConvertible.ToInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToInt32(provider);\n    long IConvertible.ToInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToInt64(provider);\n    sbyte IConvertible.ToSByte(IFormatProvider provider) => ((IConvertible)this.Value).ToSByte(provider);\n    float IConvertible.ToSingle(IFormatProvider provider) => ((IConvertible)this.Value).ToSingle(provider);\n    string IConvertible.ToString(IFormatProvider provider) => this.Value.ToString(provider);\n    object IConvertible.ToType(Type conversionType, IFormatProvider provider) => ((IConvertible)this.Value).ToType(conversionType, provider);\n    ushort IConvertible.ToUInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt16(provider);\n    uint IConvertible.ToUInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt32(provider);\n    ulong IConvertible.ToUInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt64(provider);\n    #endregion\n\n    #region IEquatable<LimitedInt>\n    public bool Equals(LimitedInt other) => this == other;\n    #endregion\n\n    #region IFormattable\n    public string ToString(string format, IFormatProvider formatProvider) => this.Value.ToString(format, formatProvider);\n    #endregion\n\n    #region operators\n    public static bool operator ==(LimitedInt left, LimitedInt right) => left.Value == right.Value;\n    public static bool operator !=(LimitedInt left, LimitedInt right) => left.Value != right.Value;\n    public static bool operator <(LimitedInt left, LimitedInt right) => left.Value < right.Value;\n    public static bool operator >(LimitedInt left, LimitedInt right) => left.Value > right.Value;\n    public static bool operator <=(LimitedInt left, LimitedInt right) => left.Value <= right.Value;\n    public static bool operator >=(LimitedInt left, LimitedInt right) => left.Value >= right.Value;\n\n    public static LimitedInt operator ++(LimitedInt left) => (LimitedInt)(left.Value + 1);\n    public static LimitedInt operator --(LimitedInt left) => (LimitedInt)(left.Value - 1);\n\n    public static LimitedInt operator +(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value + right.Value);\n    public static LimitedInt operator -(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value - right.Value);\n    public static LimitedInt operator *(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value * right.Value);\n    public static LimitedInt operator /(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value / right.Value);\n    public static LimitedInt operator %(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value % right.Value);\n\n    public static LimitedInt operator &(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value & right.Value);\n    public static LimitedInt operator |(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value | right.Value);\n    public static LimitedInt operator ^(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value ^ right.Value);\n    public static LimitedInt operator ~(LimitedInt left) => (LimitedInt)~left.Value;\n\n    public static LimitedInt operator >>(LimitedInt left, int right) => (LimitedInt)(left.Value >> right);\n    public static LimitedInt operator <<(LimitedInt left, int right) => (LimitedInt)(left.Value << right);\n\n    public static implicit operator int(LimitedInt value) => value.Value;\n    public static explicit operator LimitedInt(int value)\n    {\n        if (!IsValidValue(value)) throw new OverflowException();\n        return new LimitedInt(value);\n    }\n    #endregion\n\n    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider provider = null)\n        => this.Value.TryFormat(destination, out charsWritten, format, provider);\n\n    public override int GetHashCode() => this.Value.GetHashCode();\n    public override bool Equals(object obj) => obj is LimitedInt l && this.Equals(l);\n    public override string ToString() => this.Value.ToString();\n\n    #region static methods\n    public static bool TryParse(ReadOnlySpan<char> s, out int result) => int.TryParse(s, out result);\n    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s, IFormatProvider provider) => int.Parse(s, provider);\n    public static int Parse(string s, NumberStyles style, IFormatProvider provider) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, ref int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s) => int.Parse(s);\n    public static int Parse(string s, NumberStyles style) => int.Parse(s, style);\n    public static int Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider provider = null) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, ref int result) => int.TryParse(s, out result);\n    #endregion\n}\n"}
{"func": "using System.Diagnostics; // Debug and Trace are in this namespace.\n\nstatic class Program\n{\n    static void Main()\n    {\n        int a = 0;\n\n        Console.WriteLine(\"Before\");\n\n        // Always hit.\n        Trace.Assert(a == 42, \"Trace assertion failed\");\n\n        Console.WriteLine(\"After Trace.Assert\");\n\n        // Only hit in debug builds.\n        Debug.Assert(a == 42, \"Debug assertion failed\");\n\n        Console.WriteLine(\"After Debug.Assert\");\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace AssocArrays\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n\n            Dictionary<string,int> assocArray = new Dictionary<string,int>();\n\n            assocArray[\"Hello\"] = 1;\n            assocArray.Add(\"World\", 2);\n            assocArray[\"!\"] = 3;\n\n            foreach (KeyValuePair<string, int> kvp in assocArray)\n            {\n                Console.WriteLine(kvp.Key + \" : \" + kvp.Value);\n            }\n\n            foreach (string key in assocArray.Keys)\n            {\n                Console.WriteLine(key);\n            }\n\n            foreach (int val in assocArray.Values)\n            {\n                Console.WriteLine(val.ToString());\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"func": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"func": "using System.Drawing;\n\npublic class Pinstripe\n{\n    static void Main(string[] args)\n    {\n        var pinstripe = MakePinstripeImage(1366, 768);\n        pinstripe.Save(\"pinstripe.png\");\n    }\n\n    public static Bitmap MakePinstripeImage(int width, int height)\n    {\n        var image = new Bitmap(width, height);\n        var quarterHeight = height / 4;\n\n        for (var y = 0; y < height; y++)\n        {\n            var stripeWidth = (y / quarterHeight) + 1;\n\n            for (var x = 0; x < width; x++)\n            {\n                var color = ((x / stripeWidth) % 2) == 0 ? Color.White : Color.Black;\n                image.SetPixel(x, y, color);\n            }\n        }\n\n        return image;\n    }\n}\n"}
{"func": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main()\n        {\n            bool[] doors = new bool[100];\n\n            //The number of passes can be 1-based, but the number of doors must be 0-based.\n            for (int p = 1; p <= 100; p++)\n                for (int d = p - 1; d < 100; d += p)\n                    doors[d] = !doors[d];\n            for (int d = 0; d < 100; d++)\n                Console.WriteLine(\"Door #{0}: {1}\", d + 1, doors[d] ? \"Open\" : \"Closed\");\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace HofstadterQSequence\n{\n    class Program\n    {\n        // Initialize the dictionary with the first two indices filled.\n        private static readonly Dictionary<int, int> QList = new Dictionary<int, int>\n                                                                 {\n                                                                     {1, 1},\n                                                                     {2, 1}\n                                                                 };\n\n        private static void Main()\n        {\n            int lessThanLast = 0;\n                /* Initialize our variable that holds the number of times\n                                   * a member of the sequence was less than its preceding term. */\n\n            for (int n = 1; n <= 100000; n++)\n            {\n                int q = Q(n); // Get Q(n).\n\n                if (n > 1 && QList[n - 1] > q) // If Q(n) is less than Q(n - 1),\n                    lessThanLast++;            // then add to the counter.\n\n                if (n > 10 && n != 1000) continue; /* If n is greater than 10 and not 1000,\n                                                    * the rest of the code in the loop does not apply,\n                                                    * and it will be skipped. */\n\n                if (!Confirm(n, q)) // Confirm Q(n) is correct.\n                    throw new Exception(string.Format(\"Invalid result: Q({0}) != {1}\", n, q));\n\n                Console.WriteLine(\"Q({0}) = {1}\", n, q); // Write Q(n) to the console.\n            }\n\n            Console.WriteLine(\"Number of times a member of the sequence was less than its preceding term: {0}.\",\n                              lessThanLast);\n        }\n\n        private static bool Confirm(int n, int value)\n        {\n            if (n <= 10)\n                return new[] {1, 1, 2, 3, 3, 4, 5, 5, 6, 6}[n - 1] == value;\n            if (n == 1000)\n                return 502 == value;\n            throw new ArgumentException(\"Invalid index.\", \"n\");\n        }\n\n        private static int Q(int n)\n        {\n            int q;\n\n            if (!QList.TryGetValue(n, out q)) // Try to get Q(n) from the dictionary.\n            {\n                q = Q(n - Q(n - 1)) + Q(n - Q(n - 2)); // If it's not available, then calculate it.\n                QList.Add(n, q); // Add it to the dictionary.\n            }\n\n            return q;\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nstatic class Program\n{\n    static void Main()\n    {\n        Rectangle bounds = Screen.PrimaryScreen.Bounds;\n        Console.WriteLine($\"Primary screen bounds:  {bounds.Width}x{bounds.Height}\");\n\n        Rectangle workingArea = Screen.PrimaryScreen.WorkingArea;\n        Console.WriteLine($\"Primary screen working area:  {workingArea.Width}x{workingArea.Height}\");\n    }\n}\n"}
{"func": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"func": "using System;\n\nnamespace RosettaCode.SetOfRealNumbers\n{\n    public class Set<TValue>\n    {\n        public Set(Predicate<TValue> contains)\n        {\n            Contains = contains;\n        }\n\n        public Predicate<TValue> Contains\n        {\n            get;\n            private set;\n        }\n\n        public Set<TValue> Union(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) || set.Contains(value));\n        }\n\n        public Set<TValue> Intersection(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && set.Contains(value));\n        }\n\n        public Set<TValue> Difference(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && !set.Contains(value));\n        }\n    }\n}\n"}
{"func": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"func": "using System;\nusing System.IO;\nusing System.Text;\nusing System.Text.RegularExpressions;\nnamespace Narcisisst\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tconst string path = @\"E:\\Narcisisst\";\n\t\t\tstring[] thisFile = Directory.GetFiles(path , \"Program.cs\");\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\t\tforeach (string readLine in File.ReadLines(thisFile[0]))\n\t\t\t\t{\n\t\t\t\t\tsb.Append(readLine);\n\t\t\t\t\tsb.Append(\"\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\tConsole.WriteLine(sb);\n\t\t\tstring input =String.Empty;\n\t\t\t       \tinput = Console.ReadLine();\n\t\t\t       \tConsole.WriteLine((Regex.IsMatch(sb.ToString(),input))?\"accept\":\"reject\");\n\t\t\t       \tConsole.ReadKey();\n\t\t\t }\n\t}\n}\n"}
{"func": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main() {\n        var a = BigInteger.Parse(\"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        var b = BigInteger.Parse(\"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        var m = BigInteger.Pow(10, 40);\n        Console.WriteLine(BigInteger.ModPow(a, b, m));\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HashJoin\n{\n    public class AgeName\n    {\n        public AgeName(byte age, string name)\n        {\n            Age = age;\n            Name = name;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n    }\n\n    public class NameNemesis\n    {\n        public NameNemesis(string name, string nemesis)\n        {\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    public class DataContext\n    {\n        public DataContext()\n        {\n            AgeName = new List<AgeName>();\n            NameNemesis = new List<NameNemesis>();\n        }\n        public List<AgeName> AgeName { get; set; }\n        public List<NameNemesis> NameNemesis { get; set; }\n    }\n\n    public class AgeNameNemesis\n    {\n        public AgeNameNemesis(byte age, string name, string nemesis)\n        {\n            Age = age;\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    class Program\n    {\n        public static void Main()\n        {\n            var data = GetData();\n            var result = ExecuteHashJoin(data);\n            WriteResultToConsole(result);\n        }\n\n        private static void WriteResultToConsole(List<AgeNameNemesis> result)\n        {\n            result.ForEach(ageNameNemesis => Console.WriteLine(\"Age: {0}, Name: {1}, Nemesis: {2}\",\n                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));\n        }\n\n        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)\n        {\n            return (data.AgeName.Join(data.NameNemesis,\n                ageName => ageName.Name, nameNemesis => nameNemesis.Name,\n                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))\n                .ToList();\n        }\n\n        private static DataContext GetData()\n        {\n            var context = new DataContext();\n\n            context.AgeName.AddRange(new [] {\n                    new AgeName(27, \"Jonah\"),\n                    new AgeName(18, \"Alan\"),\n                    new AgeName(28, \"Glory\"),\n                    new AgeName(18, \"Popeye\"),\n                    new AgeName(28, \"Alan\")\n                });\n\n            context.NameNemesis.AddRange(new[]\n            {\n                new NameNemesis(\"Jonah\", \"Whales\"),\n                new NameNemesis(\"Jonah\", \"Spiders\"),\n                new NameNemesis(\"Alan\", \"Ghosts\"),\n                new NameNemesis(\"Alan\", \"Zombies\"),\n                new NameNemesis(\"Glory\", \"Buffy\")\n            });\n\n            return context;\n        }\n    }\n}\n"}
{"func": "using SYS = System;\nusing SCG = System.Collections.Generic;\n\n//\n// Basically a port of the C++ solution as posted\n// 2017-11-12.\n//\nnamespace FibonacciWord\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      PrintHeading();\n      string firstString = \"1\";\n      int n = 1;\n      PrintLine( n, firstString );\n      string secondString = \"0\";\n      ++n;\n      PrintLine( n, secondString );\n      while ( n < 37 )\n      {\n        string resultString = firstString + secondString;\n        firstString = secondString;\n        secondString = resultString;\n        ++n;\n        PrintLine( n, resultString );\n      }\n    }\n\n    private static void PrintLine( int n, string result )\n    {\n      SYS.Console.Write( \"{0,-5}\", n );\n      SYS.Console.Write( \"{0,12}\", result.Length );\n      SYS.Console.WriteLine( \"  {0,-16}\", GetEntropy( result ) );\n    }\n\n    private static double GetEntropy( string result )\n    {\n      SCG.Dictionary<char, int> frequencies = new SCG.Dictionary<char, int>();\n      foreach ( char c in result )\n      {\n        if ( frequencies.ContainsKey( c ) )\n        {\n          ++frequencies[c];\n        }\n        else\n        {\n          frequencies[c] = 1;\n        }\n      }\n\n      int length = result.Length;\n      double entropy = 0;\n      foreach ( var keyValue in frequencies )\n      {\n        double freq = (double)keyValue.Value / length;\n        entropy += freq * SYS.Math.Log( freq, 2 );\n      }\n\n      return -entropy;\n    }\n\n    private static void PrintHeading()\n    {\n      SYS.Console.Write( \"{0,-5}\", \"N\" );\n      SYS.Console.Write( \"{0,12}\", \"Length\" );\n      SYS.Console.WriteLine( \"  {0,-16}\", \"Entropy\" );\n    }\n  }\n}\n"}
{"func": "using System;\nusing System.Net;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\npublic class Semordnilap\n{\n    public static void Main() {\n        var results = FindSemordnilaps(\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\").ToList();\n        Console.WriteLine(results.Count);\n        var random = new Random();\n        Console.WriteLine(\"5 random results:\");\n        foreach (string s in results.OrderBy(_ => random.Next()).Distinct().Take(5)) Console.WriteLine(s + \" \" + Reversed(s));\n    }\n\n    private static IEnumerable<string> FindSemordnilaps(string url) {\n        var found = new HashSet<string>();\n        foreach (string line in GetLines(url)) {\n            string reversed = Reversed(line);\n            //Not taking advantage of the fact the input file is sorted\n            if (line.CompareTo(reversed) != 0) {\n                if (found.Remove(reversed)) yield return reversed;\n                else found.Add(line);\n            }\n        }\n    }\n\n    private static IEnumerable<string> GetLines(string url) {\n        WebRequest request = WebRequest.Create(url);\n        using (var reader = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n            while (!reader.EndOfStream) {\n                yield return reader.ReadLine();\n            }\n        }\n    }\n\n    private static string Reversed(string value) => new string(value.Reverse().ToArray());\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class TwelveStatements\n{\n    public static void Main() {\n        Func<Statements, bool>[] checks = {\n            st => st[1],\n            st => st[2] == (7.To(12).Count(i => st[i]) == 3),\n            st => st[3] == (2.To(12, by: 2).Count(i => st[i]) == 2),\n            st => st[4] == st[5].Implies(st[6] && st[7]),\n            st => st[5] == (!st[2] && !st[3] && !st[4]),\n            st => st[6] == (1.To(12, by: 2).Count(i => st[i]) == 4),\n            st => st[7] == (st[2] != st[3]),\n            st => st[8] == st[7].Implies(st[5] && st[6]),\n            st => st[9] == (1.To(6).Count(i => st[i]) == 3),\n            st => st[10] == (st[11] && st[12]),\n            st => st[11] == (7.To(9).Count(i => st[i]) == 1),\n            st => st[12] == (1.To(11).Count(i => st[i]) == 4)\n        };\n\n        for (Statements statements = new Statements(0); statements.Value < 4096; statements++) {\n            int count = 0;\n            int falseIndex = 0;\n            for (int i = 0; i < checks.Length; i++) {\n                if (checks[i](statements)) count++;\n                else falseIndex = i;\n            }\n            if (count == 0) Console.WriteLine($\"{\"All wrong:\", -13}{statements}\");\n            else if (count == 11) Console.WriteLine($\"{$\"Wrong at {falseIndex + 1}:\", -13}{statements}\");\n            else if (count == 12) Console.WriteLine($\"{\"All correct:\", -13}{statements}\");\n        }\n    }\n\n    struct Statements\n    {\n        public Statements(int value) : this() { Value = value; }\n\n        public int Value { get; }\n\n        public bool this[int index] => (Value & (1 << index - 1)) != 0;\n\n        public static Statements operator ++(Statements statements) => new Statements(statements.Value + 1);\n\n        public override string ToString() {\n            Statements copy = this; //Cannot access 'this' in anonymous method...\n            return string.Join(\" \", from i in 1.To(12) select copy[i] ? \"T\" : \"F\");\n        }\n\n    }\n\n    //Extension methods\n    static bool Implies(this bool x, bool y) => !x || y;\n\n    static IEnumerable<int> To(this int start, int end, int by = 1) {\n        while (start <= end) {\n            yield return start;\n            start += by;\n        }\n    }\n\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n\n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n"}
{"func": "using System;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\n\ninternal class Program\n{\n    private static readonly OrderedDictionary _holidayOffsets = new OrderedDictionary\n                                                                    {\n                                                                        {\"Easter\", 0},\n                                                                        {\"Ascension\", 39},\n                                                                        {\"Pentecost\", 49},\n                                                                        {\"Trinity\", 56},\n                                                                        {\"Corpus\", 60},\n                                                                    };\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\");\n        for (int year = 400; year <= 2100; year += 100)\n            OutputHolidays(year);\n\n        Console.WriteLine();\n        Console.WriteLine(\"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\");\n        for (int year = 2010; year <= 2020; year += 1)\n            OutputHolidays(year);\n    }\n\n    static void OutputHolidays(int year)\n    {\n        var easter = CalculateEaster(year);\n        var holidays = from kp in _holidayOffsets.OfType<DictionaryEntry>()\n                       let holiday = easter.AddDays(Convert.ToInt32(kp.Value))\n                       select kp.Key + \": \" + string.Format(\"{0,2:ddd} {0,2:%d} {0:MMM}\", holiday);\n        Console.WriteLine(\"{0,4} {1}\", year, string.Join(\", \", holidays.ToArray()));\n    }\n\n    static DateTime CalculateEaster(int year)\n    {\n        var a = year % 19;\n        var b = year / 100;\n        var c = year %100;\n        var d = b / 4;\n        var e = b % 4;\n        var f = (b + 8) / 25;\n        var g = (b - f + 1) / 3;\n        var h = (19 * a + b - d - g + 15) % 30;\n        var i = c / 4;\n        var k = c % 4;\n        var l = (32 + 2 * e + 2 * i - h - k) % 7;\n        var m = (a + 11 * h + 22 * l) / 451;\n        var numerator = h + l - 7 * m + 114;\n        var month = numerator / 31;\n        var day = (numerator % 31) + 1;\n        return new DateTime(year, month, day);\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            // Create a queue and \"push\" items into it\n            Queue<int> queue  = new Queue<int>();\n            queue.Enqueue(1);\n            queue.Enqueue(3);\n            queue.Enqueue(5);\n\n            // \"Pop\" items from the queue in FIFO order\n            Console.WriteLine(queue.Dequeue()); // 1\n            Console.WriteLine(queue.Dequeue()); // 3\n            Console.WriteLine(queue.Dequeue()); // 5\n\n            // To tell if the queue is empty, we check the count\n            bool empty = queue.Count == 0;\n            Console.WriteLine(empty); // \"True\"\n\n            // If we try to pop from an empty queue, an exception\n            // is thrown.\n            try\n            {\n                queue.Dequeue();\n            }\n            catch (InvalidOperationException exception)\n            {\n                Console.WriteLine(exception.Message); // \"Queue empty.\"\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int N = 8;\n\t\t\n\t\treadonly static int[,] moves = { {+1,-2},{+2,-1},{+2,+1},{+1,+2},\n\t\t\t                         {-1,+2},{-2,+1},{-2,-1},{-1,-2} };\n\t\tstruct ListMoves\n\t\t{\n\t\t\tpublic int x, y;\t\t\t\n\t\t\tpublic ListMoves( int _x, int _y ) { x = _x; y = _y; }\n\t\t}\t\t\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint[,] board = new int[N,N];\n\t\t\tboard.Initialize();\n\t\t\t\n\t\t\tint x = 0,\t\t\t\t\t\t// starting position\n\t\t\t    y = 0;\n\t\t\t\n\t\t\tList<ListMoves> list = new List<ListMoves>(N*N);\n\t\t\tlist.Add( new ListMoves(x,y) );\n\t\t\t\t\t\t\n\t\t\tdo\n\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\tif ( Move_Possible( board, x, y ) )\n\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tint move = board[x,y];\t\t\t\t\t\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t\tx += moves[move,0];\n\t\t\t\t\ty += moves[move,1];\t\t\t\n\t\t\t\t\tlist.Add( new ListMoves(x,y) );\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif ( board[x,y] >= 8 )\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tboard[x,y] = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tlist.RemoveAt(list.Count-1);\t\t\t\t\t\t\n\t\t\t\t\t\tif ( list.Count == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConsole.WriteLine( \"No solution found.\" );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tx = list[list.Count-1].x;\n\t\t\t\t\t\ty = list[list.Count-1].y;\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\twhile( list.Count < N*N );\n\t\t\t\n\t\t\tint last_x = list[0].x,\n\t\t\t    last_y = list[0].y;\n\t\t\tstring letters = \"ABCDEFGH\";\n\t\t\tfor( int i=1; i<list.Count; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tConsole.WriteLine( string.Format(\"{0,2}:  \", i) + letters[last_x] + (last_y+1) + \" - \" + letters[list[i].x] + (list[i].y+1) );\n\t\t\t\t\n\t\t\t\tlast_x = list[i].x;\n\t\t\t\tlast_y = list[i].y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic bool Move_Possible( int[,] board, int cur_x, int cur_y )\n\t\t{\t\t\t\n\t\t\tif ( board[cur_x,cur_y] >= 8 )\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tint new_x = cur_x + moves[board[cur_x,cur_y],0],\n\t\t\t    new_y = cur_y + moves[board[cur_x,cur_y],1];\n\t\t\t\n\t\t\tif ( new_x >= 0 && new_x < N && new_y >= 0 && new_y < N && board[new_x,new_y] == 0 )\n\t\t\t\treturn true;\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}
{"func": "using System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] a = { 1, 2, 3 };\n        int[] b = { 4, 5, 6 };\n\n        int[] c = a.Concat(b).ToArray();\n    }\n}\n"}
{"func": "namespace RosettaCode.WordWrap\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private const string LoremIpsum = @\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien\nvel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu\npharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus\nconsectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque\npenatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt\npurus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel\nfelis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta\ntortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,\ncondimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed\nvenenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu\nnibh.\";\n\n        private static void Main()\n        {\n            foreach (var lineWidth in new[] { 72, 80 })\n            {\n                Console.WriteLine(new string('-', lineWidth));\n                Console.WriteLine(Wrap(LoremIpsum, lineWidth));\n            }\n        }\n\n        private static string Wrap(string text, int lineWidth)\n        {\n            return string.Join(string.Empty,\n                               Wrap(\n                                   text.Split(new char[0],\n                                              StringSplitOptions\n                                                  .RemoveEmptyEntries),\n                                   lineWidth));\n        }\n\n        private static IEnumerable<string> Wrap(IEnumerable<string> words,\n                                                int lineWidth)\n        {\n            var currentWidth = 0;\n            foreach (var word in words)\n            {\n                if (currentWidth != 0)\n                {\n                    if (currentWidth + word.Length < lineWidth)\n                    {\n                        currentWidth++;\n                        yield return \" \";\n                    }\n                    else\n                    {\n                        currentWidth = 0;\n                        yield return Environment.NewLine;\n                    }\n                }\n                currentWidth += word.Length;\n                yield return word;\n            }\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)\n    {\n        switch (order)\n        {\n            case 0u:\n                return sequence;\n            case 1u:\n                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);\n            default:\n                return ForwardDifference(ForwardDifference(sequence), order - 1u);\n        }\n    }\n\n    static void Main()\n    {\n        IEnumerable<int> sequence = new[] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };\n        do\n        {\n            Console.WriteLine(string.Join(\", \", sequence));\n        } while ((sequence = ForwardDifference(sequence)).Any());\n    }\n}\n"}
{"func": "using System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Linq;\n\nclass XORPattern\n{\n    static void Main()\n    {\n        var size = 0x100;\n        var black = Color.Black.ToArgb();\n        var palette = Enumerable.Range(black, size).Select(Color.FromArgb).ToArray();\n        using (var image = new Bitmap(size, size))\n        {\n            for (var x = 0; x < size; x++)\n            {\n                for (var y = 0; y < size; y++)\n                {\n                    image.SetPixel(x, y, palette[x ^ y]);\n                }\n            }\n            image.Save(\"XORPatternCSharp.png\", ImageFormat.Png);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nnamespace Entropy\n{\n\tclass Program\n\t{\n\t\tpublic static double logtwo(double num)\n\t\t{\n\t\t\treturn Math.Log(num)/Math.Log(2);\n\t\t}\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\tlabel1:\n\t\t\tstring input = Console.ReadLine();\n\t\t\tdouble infoC=0;\n\t\t\tDictionary<char,double> table = new Dictionary<char, double>();\n\n\t\t\t\n\t\t\tforeach (char c in input)\n\t\t\t{\n\t\t\t\tif (table.ContainsKey(c))\n\t\t\t\t\ttable[c]++;\n\t\t\t\t    else\n\t\t\t\t    \ttable.Add(c,1);\n\t\n\t\t\t}\n\t\t\tdouble freq;\n\t\t\tforeach (KeyValuePair<char,double> letter in table)\n\t\t\t{\n\t\t\t\tfreq=letter.Value/input.Length;\n\t\t\t\tinfoC+=freq*logtwo(freq);\n\t\t\t}\n\t\t\tinfoC*=-1;\n\t\t\tConsole.WriteLine(\"The Entropy of {0} is {1}\",input,infoC);\n\t\t\tgoto label1;\n\t\t\n\t\t}\n\t}\n}\n"}
{"func": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class MatrixExponentation\n{\n    public static double[,] Identity(int size) {\n        double[,] matrix = new double[size, size];\n        for (int i = 0; i < size; i++) matrix[i, i] = 1;\n        return matrix;\n    }\n\n    public static double[,] Multiply(this double[,] left, double[,] right) {\n        if (left.ColumnCount() != right.RowCount()) throw new ArgumentException();\n        double[,] m = new double[left.RowCount(), right.ColumnCount()];\n        foreach (var (row, column) in from r in Range(0, m.RowCount()) from c in Range(0, m.ColumnCount()) select (r, c)) {\n            m[row, column] = Range(0, m.RowCount()).Sum(i => left[row, i] * right[i, column]);\n        }\n        return m;\n    }\n\n    public static double[,] Pow(this double[,] matrix, int exp) {\n        if (matrix.RowCount() != matrix.ColumnCount()) throw new ArgumentException(\"Matrix must be square.\");\n        double[,] accumulator = Identity(matrix.RowCount());\n        for (int i = 0; i < exp; i++) {\n            accumulator = accumulator.Multiply(matrix);\n        }\n        return accumulator;\n    }\n\n    private static int RowCount(this double[,] matrix) => matrix.GetLength(0);\n    private static int ColumnCount(this double[,] matrix) => matrix.GetLength(1);\n\n    private static void Print(this double[,] m) {\n        foreach (var row in Rows()) {\n            Console.WriteLine(\"[ \" + string.Join(\"   \", row) + \" ]\");\n        }\n        Console.WriteLine();\n\n        IEnumerable<IEnumerable<double>> Rows() =>\n            Range(0, m.RowCount()).Select(row => Range(0, m.ColumnCount()).Select(column => m[row, column]));\n    }\n\n    public static void Main() {\n        var matrix = new double[,] {\n            { 3, 2 },\n            { 2, 1 }\n        };\n\n        matrix.Pow(0).Print();\n        matrix.Pow(1).Print();\n        matrix.Pow(2).Print();\n        matrix.Pow(3).Print();\n        matrix.Pow(4).Print();\n        matrix.Pow(50).Print();\n    }\n\n}\n"}
{"func": "using System;\nusing System.Diagnostics;\n\nclass Program {\n    public delegate TResult ParamsFunc<T, TResult>(params T[] args);\n\n    static class Y<Result, Args> {\n        class RecursiveFunction {\n            public Func<RecursiveFunction, ParamsFunc<Args, Result>> o;\n            public RecursiveFunction(Func<RecursiveFunction, ParamsFunc<Args, Result>> o) => this.o = o;\n        }\n\n        public static ParamsFunc<Args, Result> y1(\n                Func<ParamsFunc<Args, Result>, ParamsFunc<Args, Result>> f) {\n\n            var r = new RecursiveFunction((RecursiveFunction w)\n                => f((Args[] args) => w.o(w)(args)));\n\n            return r.o(r);\n        }\n    }\n\n    static ParamsFunc<Args, Result> y2<Args, Result>(\n            Func<ParamsFunc<Args, Result>, ParamsFunc<Args, Result>> f) {\n\n        Func<dynamic, ParamsFunc<Args, Result>> r = w => {\n            Debug.Assert(w is Func<dynamic, ParamsFunc<Args, Result>>);\n            return f((Args[] args) => w(w)(args));\n        };\n\n        return r(r);\n    }\n\n    static ParamsFunc<Args, Result> y3<Args, Result>(\n            Func<ParamsFunc<Args, Result>, ParamsFunc<Args, Result>> f)\n        => (Args[] args) => f(y3(f))(args);\n\n    static void Main() {\n        var factorialY1 = Y<int, int>.y1((ParamsFunc<int, int> fact) => (int[] x)\n            => (x[0] > 1) ? x[0] * fact(x[0] - 1) : 1);\n\n        var fibY1 = Y<int, int>.y1((ParamsFunc<int, int> fib) => (int[] x)\n            => (x[0] > 2) ? fib(x[0] - 1) + fib(x[0] - 2) : 2);\n\n        Console.WriteLine(factorialY1(10)); // 362880\n        Console.WriteLine(fibY1(10));       // 110\n    }\n}\n"}
{"func": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    // implicit conversion takes care of real*quaternion and real+quaternion\n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"func": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LIS\n{\n    public static IEnumerable<T> FindRec<T>(IList<T> values, IComparer<T> comparer = null) =>\n        values == null ? throw new ArgumentNullException() :\n            FindRecImpl(values, Sequence<T>.Empty, 0, comparer ?? Comparer<T>.Default).Reverse();\n\n    private static Sequence<T> FindRecImpl<T>(IList<T> values, Sequence<T> current, int index, IComparer<T> comparer) {\n        if (index == values.Count) return current;\n        if (current.Length > 0 && comparer.Compare(values[index], current.Value) <= 0)\n            return FindRecImpl(values, current, index + 1, comparer);\n        return Max(\n            FindRecImpl(values, current, index + 1, comparer),\n            FindRecImpl(values, current + values[index], index + 1, comparer)\n        );\n    }\n\n    private static Sequence<T> Max<T>(Sequence<T> a, Sequence<T> b) => a.Length < b.Length ? b : a;\n\n    class Sequence<T> : IEnumerable<T>\n    {\n        public static readonly Sequence<T> Empty = new Sequence<T>(default(T), null);\n\n        public Sequence(T value, Sequence<T> tail)\n        {\n            Value = value;\n            Tail = tail;\n            Length = tail == null ? 0 : tail.Length + 1;\n        }\n\n        public T Value { get; }\n        public Sequence<T> Tail { get; }\n        public int Length { get; }\n\n        public static Sequence<T> operator +(Sequence<T> s, T value) => new Sequence<T>(value, s);\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            for (var s = this; s.Length > 0; s = s.Tail) yield return s.Value;\n        }\n\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n"}
{"func": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n\n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace Huffman_Encoding\n{\n    public class PriorityQueue<T> where T : IComparable\n    {\n        protected List<T> LstHeap = new List<T>();\n\n        public virtual int Count\n        {\n            get { return LstHeap.Count; }\n        }\n\n        public virtual void Add(T val)\n        {\n            LstHeap.Add(val);\n            SetAt(LstHeap.Count - 1, val);\n            UpHeap(LstHeap.Count - 1);\n        }\n\n        public virtual T Peek()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Peeking at an empty priority queue\");\n            }\n\n            return LstHeap[0];\n        }\n\n        public virtual T Pop()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Popping an empty priority queue\");\n            }\n\n            T valRet = LstHeap[0];\n\n            SetAt(0, LstHeap[LstHeap.Count - 1]);\n            LstHeap.RemoveAt(LstHeap.Count - 1);\n            DownHeap(0);\n            return valRet;\n        }\n\n        protected virtual void SetAt(int i, T val)\n        {\n            LstHeap[i] = val;\n        }\n\n        protected bool RightSonExists(int i)\n        {\n            return RightChildIndex(i) < LstHeap.Count;\n        }\n\n        protected bool LeftSonExists(int i)\n        {\n            return LeftChildIndex(i) < LstHeap.Count;\n        }\n\n        protected int ParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        protected int LeftChildIndex(int i)\n        {\n            return 2 * i + 1;\n        }\n\n        protected int RightChildIndex(int i)\n        {\n            return 2 * (i + 1);\n        }\n\n        protected T ArrayVal(int i)\n        {\n            return LstHeap[i];\n        }\n\n        protected T Parent(int i)\n        {\n            return LstHeap[ParentIndex(i)];\n        }\n\n        protected T Left(int i)\n        {\n            return LstHeap[LeftChildIndex(i)];\n        }\n\n        protected T Right(int i)\n        {\n            return LstHeap[RightChildIndex(i)];\n        }\n\n        protected void Swap(int i, int j)\n        {\n            T valHold = ArrayVal(i);\n            SetAt(i, LstHeap[j]);\n            SetAt(j, valHold);\n        }\n\n        protected void UpHeap(int i)\n        {\n            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)\n            {\n                Swap(i, ParentIndex(i));\n                i = ParentIndex(i);\n            }\n        }\n\n        protected void DownHeap(int i)\n        {\n            while (i >= 0)\n            {\n                int iContinue = -1;\n\n                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);\n                }\n                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = LeftChildIndex(i);\n                }\n\n                if (iContinue >= 0 && iContinue < LstHeap.Count)\n                {\n                    Swap(i, iContinue);\n                }\n\n                i = iContinue;\n            }\n        }\n    }\n\n    internal class HuffmanNode<T> : IComparable\n    {\n        internal HuffmanNode(double probability, T value)\n        {\n            Probability = probability;\n            LeftSon = RightSon = Parent = null;\n            Value = value;\n            IsLeaf = true;\n        }\n\n        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)\n        {\n            LeftSon = leftSon;\n            RightSon = rightSon;\n            Probability = leftSon.Probability + rightSon.Probability;\n            leftSon.IsZero = true;\n            rightSon.IsZero = false;\n            leftSon.Parent = rightSon.Parent = this;\n            IsLeaf = false;\n        }\n\n        internal HuffmanNode<T> LeftSon { get; set; }\n        internal HuffmanNode<T> RightSon { get; set; }\n        internal HuffmanNode<T> Parent { get; set; }\n        internal T Value { get; set; }\n        internal bool IsLeaf { get; set; }\n\n        internal bool IsZero { get; set; }\n\n        internal int Bit\n        {\n            get { return IsZero ? 0 : 1; }\n        }\n\n        internal bool IsRoot\n        {\n            get { return Parent == null; }\n        }\n\n        internal double Probability { get; set; }\n\n        public int CompareTo(object obj)\n        {\n            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);\n        }\n    }\n\n    public class Huffman<T> where T : IComparable\n    {\n        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();\n        private readonly HuffmanNode<T> _root;\n\n        public Huffman(IEnumerable<T> values)\n        {\n            var counts = new Dictionary<T, int>();\n            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();\n            int valueCount = 0;\n\n            foreach (T value in values)\n            {\n                if (!counts.ContainsKey(value))\n                {\n                    counts[value] = 0;\n                }\n                counts[value]++;\n                valueCount++;\n            }\n\n            foreach (T value in counts.Keys)\n            {\n                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);\n                priorityQueue.Add(node);\n                _leafDictionary[value] = node;\n            }\n\n            while (priorityQueue.Count > 1)\n            {\n                HuffmanNode<T> leftSon = priorityQueue.Pop();\n                HuffmanNode<T> rightSon = priorityQueue.Pop();\n                var parent = new HuffmanNode<T>(leftSon, rightSon);\n                priorityQueue.Add(parent);\n            }\n\n            _root = priorityQueue.Pop();\n            _root.IsZero = false;\n        }\n\n        public List<int> Encode(T value)\n        {\n            var returnValue = new List<int>();\n            Encode(value, returnValue);\n            return returnValue;\n        }\n\n        public void Encode(T value, List<int> encoding)\n        {\n            if (!_leafDictionary.ContainsKey(value))\n            {\n                throw new ArgumentException(\"Invalid value in Encode\");\n            }\n            HuffmanNode<T> nodeCur = _leafDictionary[value];\n            var reverseEncoding = new List<int>();\n            while (!nodeCur.IsRoot)\n            {\n                reverseEncoding.Add(nodeCur.Bit);\n                nodeCur = nodeCur.Parent;\n            }\n\n            reverseEncoding.Reverse();\n            encoding.AddRange(reverseEncoding);\n        }\n\n        public List<int> Encode(IEnumerable<T> values)\n        {\n            var returnValue = new List<int>();\n\n            foreach (T value in values)\n            {\n                Encode(value, returnValue);\n            }\n            return returnValue;\n        }\n\n        public T Decode(List<int> bitString, ref int position)\n        {\n            HuffmanNode<T> nodeCur = _root;\n            while (!nodeCur.IsLeaf)\n            {\n                if (position > bitString.Count)\n                {\n                    throw new ArgumentException(\"Invalid bitstring in Decode\");\n                }\n                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;\n            }\n            return nodeCur.Value;\n        }\n\n        public List<T> Decode(List<int> bitString)\n        {\n            int position = 0;\n            var returnValue = new List<T>();\n\n            while (position != bitString.Count)\n            {\n                returnValue.Add(Decode(bitString, ref position));\n            }\n            return returnValue;\n        }\n    }\n\n    internal class Program\n    {\n        private const string Example = \"this is an example for huffman encoding\";\n\n        private static void Main()\n        {\n            var huffman = new Huffman<char>(Example);\n            List<int> encoding = huffman.Encode(Example);\n            List<char> decoding = huffman.Decode(encoding);\n            var outString = new string(decoding.ToArray());\n            Console.WriteLine(outString == Example ? \"Encoding/decoding worked\" : \"Encoding/Decoding failed\");\n\n            var chars = new HashSet<char>(Example);\n            foreach (char c in chars)\n            {\n                encoding = huffman.Encode(c);\n                Console.Write(\"{0}:  \", c);\n                foreach (int bit in encoding)\n                {\n                    Console.Write(\"{0}\", bit);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Soundex\n{\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var testWords = new TestWords\n                                {\n                                    {\"Soundex\", \"S532\"},\n                                    {\"Example\", \"E251\"},\n                                    {\"Sownteks\", \"S532\"},\n                                    {\"Ekzampul\", \"E251\"},\n                                    {\"Euler\", \"E460\"},\n                                    {\"Gauss\", \"G200\"},\n                                    {\"Hilbert\", \"H416\"},\n                                    {\"Knuth\", \"K530\"},\n                                    {\"Lloyd\", \"L300\"},\n                                    {\"Lukasiewicz\", \"L222\"},\n                                    {\"Ellery\", \"E460\"},\n                                    {\"Ghosh\", \"G200\"},\n                                    {\"Heilbronn\", \"H416\"},\n                                    {\"Kant\", \"K530\"},\n                                    {\"Ladd\", \"L300\"},\n                                    {\"Lissajous\", \"L222\"},\n                                    {\"Wheaton\", \"W350\"},\n                                    {\"Burroughs\", \"B620\"},\n                                    {\"Burrows\", \"B620\"},\n                                    {\"O'Hara\", \"O600\"},\n                                    {\"Washington\", \"W252\"},\n                                    {\"Lee\", \"L000\"},\n                                    {\"Gutierrez\", \"G362\"},\n                                    {\"Pfister\", \"P236\"},\n                                    {\"Jackson\", \"J250\"},\n                                    {\"Tymczak\", \"T522\"},\n                                    {\"VanDeusen\", \"V532\"},\n                                    {\"Ashcraft\", \"A261\"}\n                                };\n\n            foreach (var testWord in testWords)\n                Console.WriteLine(\"{0} -> {1} ({2})\", testWord.Word.PadRight(11), testWord.ActualSoundex,\n                                  (testWord.ExpectedSoundex == testWord.ActualSoundex));\n        }\n\n        // List<TestWord> wrapper to make declaration simpler.\n        private class TestWords : List<TestWord>\n        {\n            public void Add(string word, string expectedSoundex)\n            {\n                Add(new TestWord(word, expectedSoundex));\n            }\n        }\n\n        private class TestWord\n        {\n            public TestWord(string word, string expectedSoundex)\n            {\n                Word = word;\n                ExpectedSoundex = expectedSoundex;\n                ActualSoundex = Soundex(word);\n            }\n\n            public string Word { get; private set; }\n            public string ExpectedSoundex { get; private set; }\n            public string ActualSoundex { get; private set; }\n        }\n\n        private static string Soundex(string word)\n        {\n            const string soundexAlphabet = \"0123012#02245501262301#202\";\n            string soundexString = \"\";\n            char lastSoundexChar = '?';\n            word = word.ToUpper();\n\n            foreach (var c in from ch in word\n                              where ch >= 'A' &&\n                                    ch <= 'Z' &&\n                                    soundexString.Length < 4\n                              select ch)\n            {\n                char thisSoundexChar = soundexAlphabet[c - 'A'];\n\n                if (soundexString.Length == 0)\n                    soundexString += c;\n                else if (thisSoundexChar == '#')\n                    continue;\n                else if (thisSoundexChar != '0' &&\n                         thisSoundexChar != lastSoundexChar)\n                    soundexString += thisSoundexChar;\n\n                lastSoundexChar = thisSoundexChar;\n            }\n\n            return soundexString.PadRight(4, '0');\n        }\n    }\n}\n"}
{"func": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //Perform the operation.\n            bool[] doors = new bool[100];\n            int n = 0;\n            int d;\n            while ((d = (++n * n)) <= 100)\n                doors[d - 1] = true;\n\n            //Perform the presentation.\n            for (d = 0; d < doors.Length; d++)\n                Console.WriteLine(\"Door #{0}: {1}\", d + 1, doors[d] ? \"Open\" : \"Closed\");\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"func": "using System;\n\nstatic class Program\n{\n    static void Main()\n    {\n        int factorial;\n        factorial = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n        Console.WriteLine(factorial);\n    }\n}\n"}
{"func": "using System.Linq;\n\nstatic class Program\n{\n    static void Main()\n    {\n        string[] keys = { \"foo\", \"bar\", \"val\" };\n        string[] values = { \"little\", \"miss\", \"muffet\" };\n\n        var h = keys\n            .Zip(values, (k, v) => (k, v))\n            .ToDictionary(keySelector: kv => kv.k, elementSelector: kv => kv.v);\n    }\n}\n"}
{"func": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nnamespace BasicAnimation\n{\n  class BasicAnimationForm : Form\n  {\n    bool isReverseDirection;\n    Label textLabel;\n    Timer timer;\n\n    internal BasicAnimationForm()\n    {\n      this.Size = new Size(150, 75);\n      this.Text = \"Basic Animation\";\n\n      textLabel = new Label();\n      textLabel.Text = \"Hello World! \";\n      textLabel.Location = new Point(3,3);\n      textLabel.AutoSize = true;\n      textLabel.Click += new EventHandler(textLabel_OnClick);\n      this.Controls.Add(textLabel);\n\n      timer = new Timer();\n      timer.Interval = 500;\n      timer.Tick += new EventHandler(timer_OnTick);\n      timer.Enabled = true;\n\n      isReverseDirection = false;\n    }\n\n    private void timer_OnTick(object sender, EventArgs e)\n    {\n      string oldText = textLabel.Text, newText;\n      if(isReverseDirection)\n        newText = oldText.Substring(1, oldText.Length - 1) + oldText.Substring(0, 1);\n      else\n        newText = oldText.Substring(oldText.Length - 1, 1) + oldText.Substring(0, oldText.Length - 1);\n      textLabel.Text = newText;\n    }\n\n    private void textLabel_OnClick(object sender, EventArgs e)\n    {\n      isReverseDirection = !isReverseDirection;\n    }\n  }\n\n   class Program\n   {\n      static void Main()\n      {\n\tApplication.Run(new BasicAnimationForm());\n      }\n   }\n}\n"}
{"func": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tRandom rnd = new Random();\n\t\t\t\n\t\t\ts.AppendLine(\"<table>\");\n\t\t\ts.AppendLine(\"<thead align = \\\"right\\\">\");\n\t\t\ts.Append(\"<tr><th></th>\");\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t\ts.Append(\"<td>\" + \"XYZ\"[i] + \"</td>\");\n\t\t\ts.AppendLine(\"</tr>\");\n\t\t\ts.AppendLine(\"</thead>\");\n\t\t\ts.AppendLine(\"<tbody align = \\\"right\\\">\");\n\t\t\tfor( int i=0; i<3; i++ )\n\t\t\t{\n\t\t\t\ts.Append(\"<tr><td>\"+i+\"</td>\");\n\t\t\t\tfor( int j=0; j<3; j++ )\n\t\t\t\t\ts.Append(\"<td>\"+rnd.Next(10000)+\"</td>\");\t\t\t\t\n\t\t\t\ts.AppendLine(\"</tr>\");\n\t\t\t}\n\t\t\ts.AppendLine(\"</tbody>\");\n\t\t\ts.AppendLine(\"</table>\");\n\t\t\t\n\t\t\tConsole.WriteLine( s );\n\t\t}\n\t}\n}\n"}
{"func": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        //other puzzle types elided\n        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};\n\n    private (int dx, int dy)[] moves;\n\n    public static void Main()\n    {\n        Print(new Solver(hidatoMoves).Solve(false, new [,] {\n            {  0, 33, 35,  0,  0, -1, -1, -1 },\n            {  0,  0, 24, 22,  0, -1, -1, -1 },\n            {  0,  0,  0, 21,  0,  0, -1, -1 },\n            {  0, 26,  0, 13, 40, 11, -1, -1 },\n            { 27,  0,  0,  0,  9,  0,  1, -1 },\n            { -1, -1,  0,  0, 18,  0,  0, -1 },\n            { -1, -1, -1, -1,  0,  7,  0,  0 },\n            { -1, -1, -1, -1, -1, -1,  5,  0 }\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"func": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        // build input table and calculate columns count\n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        // create formatted table\n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            // get max column width\n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            // justify column cells\n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else\n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        // create result\n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width)\n    {\n        return s.PadLeft((width + s.Length) / 2).PadRight(width);\n    }\n\n    static void Main()\n    {\n        string[] input = {\n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"func": "using System;\n\nstatic class YCombinator {\n    interface Function<T, R> {\n        R apply(T t);\n    }\n\n    interface RecursiveFunction<F> : Function<RecursiveFunction<F>, F> {\n    }\n\n    static class Y<A, B> {\n        class __1 : RecursiveFunction<Function<A, B>> {\n            class __2 : Function<A, B> {\n                readonly RecursiveFunction<Function<A, B>> w;\n\n                public __2(RecursiveFunction<Function<A, B>> w) {\n                    this.w = w;\n                }\n\n                public B apply(A x) {\n                    return w.apply(w).apply(x);\n                }\n            }\n\n            Function<Function<A, B>, Function<A, B>> f;\n\n            public __1(Function<Function<A, B>, Function<A, B>> f) {\n                this.f = f;\n            }\n\n            public Function<A, B> apply(RecursiveFunction<Function<A, B>> w) {\n                return f.apply(new __2(w));\n            }\n        }\n\n        public static Function<A, B> _(Function<Function<A, B>, Function<A, B>> f) {\n            var r = new __1(f);\n            return r.apply(r);\n        }\n    }\n\n    class __1 : Function<Function<int, int>, Function<int, int>> {\n        class __2 : Function<int, int> {\n            readonly Function<int, int> f;\n\n            public __2(Function<int, int> f) {\n                this.f = f;\n            }\n\n            public int apply(int n) {\n                return\n                    (n <= 2)\n                  ? 1\n                  : (f.apply(n - 1) + f.apply(n - 2));\n            }\n        }\n\n        public Function<int, int> apply(Function<int, int> f) {\n            return new __2(f);\n        }\n    }\n\n    class __2 : Function<Function<int, int>, Function<int, int>> {\n        class __3 : Function<int, int> {\n            readonly Function<int, int> f;\n\n            public __3(Function<int, int> f) {\n                this.f = f;\n            }\n\n            public int apply(int n) {\n                return\n                    (n <= 1)\n                  ? 1\n                  : (n * f.apply(n - 1));\n            }\n        }\n\n        public Function<int, int> apply(Function<int, int> f) {\n            return new __3(f);\n        }\n    }\n\n    static void Main(params String[] arguments) {\n        Function<int, int> fib = Y<int, int>._(new __1());\n        Function<int, int> fac = Y<int, int>._(new __2());\n\n        Console.WriteLine(\"fib(10) = \" + fib.apply(10));\n        Console.WriteLine(\"fac(10) = \" + fac.apply(10));\n    }\n}\n"}
{"func": "using System.Collections.Generic;\nusing System.IO;\n\nclass Program {\n    static void Main() {\n        var files = new List<string> {\n            \"test1.txt\",\n            \"test2.txt\"\n        };\n        foreach (string file in files) {\n            File.WriteAllText(file, File.ReadAllText(file).Replace(\"Goodbye London!\", \"Hello New York!\"));\n        }\n    }\n}\n"}
{"func": "using System; //Rand class\nusing System.Threading; //Thread, Mutex classes\npublic class ThreadSafeBuckets\n{\n    //This class is thread safe, and ensures that all operations on it are atomic.\n    //Calling threads do not need to ensure safety.\n    Random rand = new Random();\n    int[] Buckets;\n    object[] locks; //Mutexes for each bucket so they can lock individually\n    public int BucketCount { get; private set; }\n    public ThreadSafeBuckets(int bucketcount)\n    {\n        //Create buckets+mutexes and fill them with a random amount\n        BucketCount = bucketcount;\n        Buckets = new int[bucketcount];\n        locks = new object[bucketcount];\n        int startingtotal = 0;\n        for (int i = 0; i < BucketCount; i++)\n        {\n            locks[i] = new object();\n            Buckets[i] = rand.Next(30);\n            startingtotal += Buckets[i];\n        }\n        //Print the starting total\n        Console.WriteLine(\"Starting total: \" + startingtotal);\n    }\n    public int GetBucketValue(int i)\n    {\n        return Buckets[i];\n    }\n    public void Transfer(int i, int j, int amount)\n    {\n        //Transfer amount from bucket i to bucket j\n        if (i > BucketCount || j > BucketCount || i < 0 || j < 0 ||\n            i == j || amount < 0)\n            return;\n\n        //To prevent deadlock, always lock the lower bucket first\n        lock (locks[Math.Min(i, j)])\n            lock (locks[Math.Max(i, j)])\n            {\n                //Make sure don't transfer out more than is in the bucket\n                amount = Math.Min(amount, Buckets[i]);\n\n                //Do the transfer\n                Buckets[i] -= amount;\n                Buckets[j] += amount;\n            }\n    }\n\n    public void PrintBuckets()\n    {\n        int counter = 0;\n        //Lock all the buckets in sequential order and print their contents\n        for (int i = 0; i < BucketCount; i++)\n        {\n            Monitor.Enter(locks[i]);\n            Console.Write(Buckets[i] + \" \");\n            counter += Buckets[i];\n        }\n        //Print the bucket total, then unlock all the mutexes\n        Console.Write(\"= \" + counter);\n        Console.WriteLine();\n\n        foreach (var l in locks)\n            Monitor.Exit(l);\n    }\n}\n\nclass Program\n{\n    static ThreadSafeBuckets TSBs;\n\n    public static void Main(){\n        //Create the thread-safe bucket list\n        TSBs = new ThreadSafeBuckets(10);\n        TSBs.PrintBuckets();\n        //Create and start the Equalizing Thread\n        new Thread(new ThreadStart(EqualizerThread)).Start();\n        Thread.Sleep(1);\n        //Create and start the Randamizing Thread\n        new Thread(new ThreadStart(RandomizerThread)).Start();\n        //Use this thread to do the printing\n        PrinterThread();\n    }\n    //EqualizerThread runs on it's own thread and randomly averages two buckets\n    static void EqualizerThread()\n    {\n        Random rand = new Random();\n        while (true)\n        {\n            //Pick two buckets\n            int b1 = rand.Next(TSBs.BucketCount);\n            int b2 = rand.Next(TSBs.BucketCount);\n            //Get the difference\n            int diff = TSBs.GetBucketValue(b1) - TSBs.GetBucketValue(b2);\n            //Transfer to equalize\n            if (diff < 0)\n                TSBs.Transfer(b2, b1, -diff / 2);\n            else\n                TSBs.Transfer(b1, b2, diff/2);\n        }\n    }\n    //RandomizerThread redistributes the values between two buckets\n    static void RandomizerThread()\n    {\n        Random rand = new Random();\n        while (true)\n        {\n            int b1 = rand.Next(TSBs.BucketCount);\n            int b2 = rand.Next(TSBs.BucketCount);\n            int diff = rand.Next(TSBs.GetBucketValue(b1));\n            TSBs.Transfer(b1, b2, diff);\n        }\n    }\n    //PrinterThread prints the current bucket contents\n    static void PrinterThread()\n    {\n        while (true)\n        {\n            Thread.Sleep(50); //Only print every few milliseconds to let the other threads work\n            TSBs.PrintBuckets();\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            //List<string> menu_items = new List<string>();\n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"func": "using System;\n\nclass SubStringTestClass\n{\n   public static int CountSubStrings(this string testString, string testSubstring)\n   {\n        int count = 0;\n\n        if (testString.Contains(testSubstring))\n        {\n            for (int i = 0; i < testString.Length; i++)\n            {\n                if (testString.Substring(i).Length >= testSubstring.Length)\n                {\n                    bool equals = testString.Substring(i, testSubstring.Length).Equals(testSubstring);\n                    if (equals)\n                    {\n                        count++;\n                        i += testSubstring.Length - 1;  // Fix: Don't count overlapping matches\n                    }\n                }\n            }\n        }\n        return count;\n   }\n}\n"}
{"func": "using System;\n\nnamespace cipher {\n\nstatic class Cipher {\n\n// external results\nstatic uint[] randrsl = new uint[256];\nstatic uint randcnt;\n// internal state\nstatic uint[] mm = new uint[256];\nstatic uint aa=0, bb=0, cc=0;\n\n\nstatic void isaac() {\n   uint i,x,y;\n   cc++;    // cc just gets incremented once per 256 results\n   bb+=cc;   // then combined with bb\n\n   for (i=0; i<=255; i++) {\n     x = mm[i];\n     switch (i & 3) {\n      case 0: aa = aa ^ (aa << 13); break;\n      case 1: aa = aa ^ (aa >> 6); break;\n      case 2: aa = aa ^ (aa << 2); break;\n      case 3: aa = aa ^ (aa >> 16); break;\n     }\n     aa = mm[(i+128) & 255] + aa;\n     y  = mm[(x >> 2) & 255] + aa + bb;\n     mm[i] = y; \t\n     bb = mm[(y >> 10) & 255] + x;\n     randrsl[i]= bb;\n   }\n}\n\n\n// if (flag==TRUE), then use the contents of randrsl[] to initialize mm[].\nstatic void mix(ref uint a, ref uint b, ref uint c, ref uint d, ref uint e, ref uint f, ref uint g, ref uint h) {\n   a = a ^ b << 11; d+=a; b+=c;\n   b = b ^ c >> 2;  e+=b; c+=d;\n   c = c ^ d << 8;  f+=c; d+=e;\n   d = d ^ e >> 16; g+=d; e+=f;\n   e = e ^ f << 10; h+=e; f+=g;\n   f = f ^ g >> 4;  a+=f; g+=h;\n   g = g ^ h << 8;  b+=g; h+=a;\n   h = h ^ a >> 9;  c+=h; a+=b;\n}\n\n\nstatic void Init(bool flag) {\n  short i; uint a,b,c,d,e,f,g,h;\n\n   aa=0; bb=0; cc=0;\n   a=0x9e3779b9; b=a; c=a; d=a;\n   e=a; f=a; g=a; h=a;\n\n   for (i=0; i<=3; i++)           // scramble it\n        mix(ref a,ref b,ref c,ref d,ref e,ref f,ref g,ref h);\n\n   i=0;\n   do  { // fill in mm[] with messy stuff\n          if (flag) {     // use all the information in the seed\n            a+=randrsl[i  ]; b+=randrsl[i+1]; c+=randrsl[i+2]; d+=randrsl[i+3];\n            e+=randrsl[i+4]; f+=randrsl[i+5]; g+=randrsl[i+6]; h+=randrsl[i+7];\n          } // if flag\n\n      mix(ref a,ref b,ref c,ref d,ref e,ref f,ref g,ref h);\n      mm[i  ]=a; mm[i+1]=b; mm[i+2]=c; mm[i+3]=d;\n      mm[i+4]=e; mm[i+5]=f; mm[i+6]=g; mm[i+7]=h;\n      i+=8;\n      }\n   while (i<255);\n\n   if (flag) {\n   // do a second pass to make all of the seed affect all of mm\n     i=0;\n     do {\n      a+=mm[i  ]; b+=mm[i+1]; c+=mm[i+2]; d+=mm[i+3];\n      e+=mm[i+4]; f+=mm[i+5]; g+=mm[i+6]; h+=mm[i+7];\n      mix(ref a,ref b,ref c,ref d,ref e,ref f,ref g,ref h);\n      mm[i  ]=a; mm[i+1]=b; mm[i+2]=c; mm[i+3]=d;\n      mm[i+4]=e; mm[i+5]=f; mm[i+6]=g; mm[i+7]=h;\n      i+=8;\n        }\n     while (i<255);\n   }\n   isaac();           // fill in the first set of results\n   randcnt=0;       // prepare to use the first set of results\n}\n\n\n// Seed ISAAC with a string\nstatic void Seed(string seed, bool flag) {\n\tfor (int i=0; i<256; i++) mm[i]=0;\n\tfor (int i=0; i<256; i++) randrsl[i]=0;\n\tint m = seed.Length;\n\tfor (int i=0; i<m; i++) {\n        randrsl[i] = seed[i];\n\t}\n\t// initialize ISAAC with seed\n\tInit(flag);\n}\n\n\n// Get a random 32-bit value\nstatic uint Random() {\n    uint result = randrsl[randcnt];\n    randcnt++;\n    if (randcnt>255) {\n         isaac(); randcnt=0;\n    }\n    return result;\n}\n\n\n// Get a random character in printable ASCII range\nstatic byte RandA() {\t\n\treturn (byte)(Random() % 95 + 32);\n}\n\n\n// XOR encrypt on random stream. Output: ASCII byte array\nstatic byte[] Vernam(string msg)\n\t{\n\t\tint n,l;\n\t\tbyte[] v = new byte[msg.Length];\n\t\tl = msg.Length;\n\t\t// XOR message\n\t\tfor (n=0; n<l; n++) {\n\t\t\tv[n] = (byte) (RandA() ^ (byte)msg[n]);\n\t\t}\t\n\t\treturn v;\n\t}\n\n\t\n\tpublic static void Main() {\n\t\tstring msg = \"a Top Secret secret\";\n\t\tstring key = \"this is my secret key\";\n\t\tbyte[] xctx= new byte[msg.Length];\n\t\tbyte[] xptx= new byte[msg.Length];\n\t\tstring xtcx= \"*******************\";\n\t\tstring xtpx= \"*******************\";\n\t\tSeed(key,true);\n\t\t// XOR encrypt\n\t\txctx = Vernam(msg);\n\t\txtcx = System.Text.Encoding.ASCII.GetString(xctx);\n\t\t// XOR decrypt\n\t\tSeed(key,true);\n\t\txptx = Vernam(xtcx);\n\t\txtpx = System.Text.Encoding.ASCII.GetString(xptx);\n\t\tConsole.WriteLine(\"Message: \"+msg);\n\t\tConsole.WriteLine(\"Key    : \"+key);\n\t\tConsole.Write    (\"XOR    : \");\n\t\t// output ciphertext as a string of hexadecimal digits\n\t\tfor (int n=0; n<xctx.Length; n++) Console.Write(\"{0:X2}\", xctx[n]);\n\t\tConsole.WriteLine(\"\\nXOR dcr: \"+xtpx);\n\t}\n}\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Func<TimeSpan, double> TimeToDegrees = (time) =>\n                360 * time.Hours / 24.0 +\n                360 * time.Minutes / (24 * 60.0) +\n                360 * time.Seconds / (24 * 3600.0);\n            Func<List<double>, double> MeanAngle = (angles) =>\n                {\n                    double y_part = 0.0d, x_part = 0.0d;\n                    int numItems = angles.Count;\n\n                    for (int i = 0; i < numItems; i++)\n                    {\n                        x_part += Math.Cos(angles[i] * Math.PI / 180);\n                        y_part += Math.Sin(angles[i] * Math.PI / 180);\n                    }\n\n                    return Math.Atan2(y_part / numItems, x_part / numItems) * 180 / Math.PI;\n                };\n            Func<double, TimeSpan> TimeFromDegrees = (angle) =>\n                    new TimeSpan(\n                        (int)(24 * 60 * 60 * angle / 360) / 3600,\n                        ((int)(24 * 60 * 60 * angle / 360) % 3600 - (int)(24 * 60 * 60 * angle / 360) % 60) / 60,\n                        (int)(24 * 60 * 60 * angle / 360) % 60);\n            List<double> digitimes = new List<double>();\n            TimeSpan digitime;\n            string input;\n\n            Console.WriteLine(\"Enter times, end with no input: \");\n            do\n            {\n                input = Console.ReadLine();\n                if (!(string.IsNullOrWhiteSpace(input)))\n                {\n                    if (TimeSpan.TryParse(input, out digitime))\n                        digitimes.Add(TimeToDegrees(digitime));\n                    else\n                        Console.WriteLine(\"Seems this is wrong input: ignoring time\");\n                }\n            } while (!string.IsNullOrWhiteSpace(input));\n\n            if(digitimes.Count() > 0)\n                Console.WriteLine(\"The mean time is : {0}\", TimeFromDegrees(360 + MeanAngle(digitimes)));\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Numerics;\n\nstatic class Program {\n    static void Main() {\n        BigInteger n = BigInteger.Pow(5, (int)BigInteger.Pow(4, (int)BigInteger.Pow(3, 2)));\n        string result = n.ToString();\n\n        Debug.Assert(result.Length == 183231);\n        Debug.Assert(result.StartsWith(\"62060698786608744707\"));\n        Debug.Assert(result.EndsWith(\"92256259918212890625\"));\n\n        Console.WriteLine(\"n = 5^4^3^2\");\n        Console.WriteLine(\"n = {0}...{1}\",\n            result.Substring(0, 20),\n            result.Substring(result.Length - 20, 20)\n            );\n\n        Console.WriteLine(\"n digits = {0}\", result.Length);\n    }\n}\n"}
{"func": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA1\n{\n    [TestClass]\n    public class SHA1CryptoServiceProviderTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var input = new UTF8Encoding().GetBytes(\"Rosetta Code\");\n            var output = new SHA1CryptoServiceProvider().ComputeHash(input);\n            Assert.AreEqual(\n                \"48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5\",\n                BitConverter.ToString(output));\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Diagnostics;\n\nstatic class Program {\n    delegate TResult ParamsFunc<T, TResult>(params T[] args);\n\n    static class Y<Result, Args> {\n        class RecursiveFunction {\n            public Func<RecursiveFunction, ParamsFunc<Args, Result>> o;\n            public RecursiveFunction(Func<RecursiveFunction, ParamsFunc<Args, Result>> o) => this.o = o;\n        }\n\n        public static ParamsFunc<Args, Result> y1(\n                Func<ParamsFunc<Args, Result>, ParamsFunc<Args, Result>> f) {\n\n            var r = new RecursiveFunction(w => f(args => w.o(w)(args)));\n\n            return r.o(r);\n        }\n    }\n\n    static ParamsFunc<Args, Result> y2<Args, Result>(\n            Func<ParamsFunc<Args, Result>, ParamsFunc<Args, Result>> f) {\n\n        Func<dynamic, ParamsFunc<Args, Result>> r = w => {\n            Debug.Assert(w is Func<dynamic, ParamsFunc<Args, Result>>);\n            return f(args => w(w)(args));\n        };\n\n        return r(r);\n    }\n\n    static ParamsFunc<Args, Result> y3<Args, Result>(\n            Func<ParamsFunc<Args, Result>, ParamsFunc<Args, Result>> f)\n        => args => f(y3(f))(args);\n\n    static void Main() {\n        var factorialY1 = Y<int, int>.y1(fact => x => (x[0] > 1) ? x[0] * fact(x[0] - 1) : 1);\n        var fibY1 = Y<int, int>.y1(fib => x => (x[0] > 2) ? fib(x[0] - 1) + fib(x[0] - 2) : 2);\n\n        Console.WriteLine(factorialY1(10));\n        Console.WriteLine(fibY1(10));\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nnamespace Amb\n{\n    public interface IValue<T>\n    {\n        T Value { get; }\n        string ToString();\n    }\n\n    public sealed class Amb\n    {\n        public IValue<T> Choose<T>(params T[] choices)\n        {\n            var array = new ChoiceArray<T> { Values = choices };\n            _itemsChoices.Add(array);\n            return array;\n        }\n\n        public void Require(Func<bool> predicate) =>\n            _constraints.Add(new Constraint { Predicate = predicate, AppliesForItems = _itemsChoices.Count });\n\n        public bool RequireFinal(Func<bool> predicate)\n        {\n            Require(predicate);\n            return Disambiguate();\n        }\n\n        public bool Disambiguate()\n        {\n            try\n            {\n                Disambiguate(0, 0);\n                return false;\n            }\n            catch (Exception ex) when (ex.Message == \"Success\")\n            {\n                return true;\n            }\n        }\n\n        interface IChoices\n        {\n            int Length { get; }\n            int Index { get; set; }\n        }\n\n        interface IConstraint\n        {\n            int AppliesForItems { get; }\n            bool Invoke();\n        }\n\n        List<IChoices> _itemsChoices = new List<IChoices>();\n        List<IConstraint> _constraints = new List<IConstraint>();\n\n        void Disambiguate(int itemsTracked, int constraintIndex)\n        {\n            while (constraintIndex < _constraints.Count && _constraints[constraintIndex].AppliesForItems <= itemsTracked)\n            {\n                if (!_constraints[constraintIndex].Invoke())\n                    return;\n                constraintIndex++;\n            }\n\n            if (itemsTracked == _itemsChoices.Count)\n            {\n                throw new Exception(\"Success\");\n            }\n\n            for (var i = 0; i < _itemsChoices[itemsTracked].Length; i++)\n            {\n                 _itemsChoices[itemsTracked].Index = i;\n                 Disambiguate(itemsTracked + 1, constraintIndex);\n            }\n        }\n\n        class Constraint : IConstraint\n        {\n            internal int AppliesForItems;\n            int IConstraint.AppliesForItems => AppliesForItems;\n\n            internal Func<bool> Predicate;\n            public bool Invoke() => Predicate?.Invoke() ?? default;\n        }\n\n        class ChoiceArray<T> : IChoices, IValue<T>\n        {\n            internal T[] Values;\n\n            public int Index { get; set; }\n\n            public T Value { get { return Values[Index]; } }\n\n            public int Length => Values.Length;\n\n            public override string ToString() => Value.ToString();\n        }\n    }\n}\n"}
{"func": "using System;\n\npublic struct ComplexNumber\n{\n    public static readonly ComplexNumber i = new ComplexNumber(0.0, 1.0);\n    public static readonly ComplexNumber Zero = new ComplexNumber(0.0, 0.0);\n\n    public double Re;\n    public double Im;\n\n    public ComplexNumber(double re)\n    {\n        this.Re = re;\n        this.Im = 0;\n    }\n\n    public ComplexNumber(double re, double im)\n    {\n        this.Re = re;\n        this.Im = im;\n    }\n\n    public static ComplexNumber operator *(ComplexNumber n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1.Re * n2.Re - n1.Im * n2.Im,\n            n1.Im * n2.Re + n1.Re * n2.Im);\n    }\n\n    public static ComplexNumber operator *(double n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1 * n2.Re, n1 * n2.Im);\n    }\n\n    public static ComplexNumber operator /(ComplexNumber n1, ComplexNumber n2)\n    {\n        double n2Norm = n2.Re * n2.Re + n2.Im * n2.Im;\n        return new ComplexNumber((n1.Re * n2.Re + n1.Im * n2.Im) / n2Norm,\n            (n1.Im * n2.Re - n1.Re * n2.Im) / n2Norm);\n    }\n\n    public static ComplexNumber operator /(ComplexNumber n1, double n2)\n    {\n        return new ComplexNumber(n1.Re / n2, n1.Im / n2);\n    }\n\n    public static ComplexNumber operator +(ComplexNumber n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1.Re + n2.Re, n1.Im + n2.Im);\n    }\n\n    public static ComplexNumber operator -(ComplexNumber n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1.Re - n2.Re, n1.Im - n2.Im);\n    }\n\n    public static ComplexNumber operator -(ComplexNumber n)\n    {\n        return new ComplexNumber(-n.Re, -n.Im);\n    }\n\n    public static implicit operator ComplexNumber(double n)\n    {\n        return new ComplexNumber(n, 0.0);\n    }\n\n    public static explicit operator double(ComplexNumber n)\n    {\n        return n.Re;\n    }\n\n    public static bool operator ==(ComplexNumber n1, ComplexNumber n2)\n    {\n        return n1.Re == n2.Re && n1.Im == n2.Im;\n    }\n\n    public static bool operator !=(ComplexNumber n1, ComplexNumber n2)\n    {\n        return n1.Re != n2.Re || n1.Im != n2.Im;\n    }\n\n    public override bool Equals(object obj)\n    {\n        return this == (ComplexNumber)obj;\n    }\n\n    public override int GetHashCode()\n    {\n        return Re.GetHashCode() ^ Im.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return String.Format(\"{0}+{1}*i\", Re, Im);\n    }\n}\n\npublic static class ComplexMath\n{\n    public static double Abs(ComplexNumber a)\n    {\n        return Math.Sqrt(Norm(a));\n    }\n\n    public static double Norm(ComplexNumber a)\n    {\n        return a.Re * a.Re + a.Im * a.Im;\n    }\n\n    public static double Arg(ComplexNumber a)\n    {\n        return Math.Atan2(a.Im, a.Re);\n    }\n\n    public static ComplexNumber Inverse(ComplexNumber a)\n    {\n        double norm = Norm(a);\n        return new ComplexNumber(a.Re / norm, -a.Im / norm);\n    }\n\n    public static ComplexNumber Conjugate(ComplexNumber a)\n    {\n        return new ComplexNumber(a.Re, -a.Im);\n\n    }\n\n    public static ComplexNumber Exp(ComplexNumber a)\n    {\n        double e = Math.Exp(a.Re);\n        return new ComplexNumber(e * Math.Cos(a.Im), e * Math.Sin(a.Im));\n    }\n\n    public static ComplexNumber Log(ComplexNumber a)\n    {\n\n        return new ComplexNumber(0.5 * Math.Log(Norm(a)), Arg(a));\n    }\n\n    public static ComplexNumber Power(ComplexNumber a, ComplexNumber power)\n    {\n        return Exp(power * Log(a));\n    }\n\n    public static ComplexNumber Power(ComplexNumber a, int power)\n    {\n        bool inverse = false;\n        if (power < 0)\n        {\n            inverse = true; power = -power;\n        }\n\n        ComplexNumber result = 1.0;\n        ComplexNumber multiplier = a;\n        while (power > 0)\n        {\n            if ((power & 1) != 0) result *= multiplier;\n            multiplier *= multiplier;\n            power >>= 1;\n        }\n\n        if (inverse)\n            return Inverse(result);\n        else\n            return result;\n    }\n\n    public static ComplexNumber Sqrt(ComplexNumber a)\n    {\n        return Exp(0.5 * Log(a));\n    }\n\n    public static ComplexNumber Sin(ComplexNumber a)\n    {\n        return Sinh(ComplexNumber.i * a) / ComplexNumber.i;\n    }\n\n    public static ComplexNumber Cos(ComplexNumber a)\n    {\n        return Cosh(ComplexNumber.i * a);\n    }\n\n    public static ComplexNumber Sinh(ComplexNumber a)\n    {\n        return 0.5 * (Exp(a) - Exp(-a));\n    }\n\n    public static ComplexNumber Cosh(ComplexNumber a)\n    {\n        return 0.5 * (Exp(a) + Exp(-a));\n    }\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // usage\n        ComplexNumber i = 2;\n        ComplexNumber j = new ComplexNumber(1, -2);\n        Console.WriteLine(i * j);\n        Console.WriteLine(ComplexMath.Power(j, 2));\n        Console.WriteLine((double)ComplexMath.Sin(i) + \" vs \" + Math.Sin(2));\n        Console.WriteLine(ComplexMath.Power(j, 0) == 1.0);\n    }\n}\n"}
{"func": "using System.Collections.Generic;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        LinkedList<string> list = new LinkedList<string>();\n        list.AddFirst(\".AddFirst() adds at the head.\");\n        list.AddLast(\".AddLast() adds at the tail.\");\n        LinkedListNode<string> head = list.Find(\".AddFirst() adds at the head.\");\n        list.AddAfter(head, \".AddAfter() adds after a specified node.\");\n        LinkedListNode<string> tail = list.Find(\".AddLast() adds at the tail.\");\n        list.AddBefore(tail, \"Betcha can't guess what .AddBefore() does.\");\n\n        System.Console.WriteLine(\"Forward:\");\n        foreach (string nodeValue in list) { System.Console.WriteLine(nodeValue); }\n\n        System.Console.WriteLine(\"\\nBackward:\");\n        LinkedListNode<string> current = tail;\n        while (current != null)\n        {\n            System.Console.WriteLine(current.Value);\n            current = current.Previous;\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"func": "using System;\n\nclass Program {\n    static void Main (string[] args) {\n        string example = string.Empty;\n        if (string.IsNullOrEmpty(example)) { }\n        if (!string.IsNullOrEmpty(example)) { }\n    }\n}\n"}
{"func": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic static class OrderedPartitions\n{\n    public static void Main() {\n        var input = new [] { new[] { 0, 0, 0, 0, 0 }, new[] { 2, 0, 2 }, new[] { 1, 1, 1 } };\n        foreach (int[] sizes in input) {\n            foreach (var partition in Partitions(sizes)) {\n                Console.WriteLine(partition.Select(set => set.Delimit(\", \").Encase('{','}')).Delimit(\", \").Encase('(', ')'));\n            }\n            Console.WriteLine();\n        }\n    }\n\n    static IEnumerable<IEnumerable<int[]>> Partitions(params int[] sizes) {\n        var enumerators = new IEnumerator<int[]>[sizes.Length];\n        var unused = Enumerable.Range(1, sizes.Sum()).ToSortedSet();\n        var arrays = sizes.Select(size => new int[size]).ToArray();\n\n        for (int s = 0; s >= 0; ) {\n            if (s == sizes.Length) {\n                yield return arrays;\n                s--;\n            }\n            if (enumerators[s] == null) {\n                enumerators[s] = Combinations(sizes[s], unused.ToArray()).GetEnumerator();\n            } else {\n                unused.UnionWith(arrays[s]);\n            }\n            if (enumerators[s].MoveNext()) {\n                enumerators[s].Current.CopyTo(arrays[s], 0);\n                unused.ExceptWith(arrays[s]);\n                s++;\n            } else {\n                enumerators[s] = null;\n                s--;\n            }\n        }\n    }\n\n    static IEnumerable<T[]> Combinations<T>(int count, params T[] array) {\n        T[] result = new T[count];\n        foreach (int pattern in BitPatterns(array.Length - count, array.Length)) {\n            for (int b = 1 << (array.Length - 1), i = 0, r = 0; b > 0; b >>= 1, i++) {\n                if ((pattern & b) == 0) result[r++] = array[i];\n            }\n            yield return result;\n        }\n    }\n\n    static IEnumerable<int> BitPatterns(int ones, int length) {\n        int initial = (1 << ones) - 1;\n        int blockMask = (1 << length) - 1;\n        for (int v = initial; v >= initial; ) {\n            yield return v;\n            if (v == 0) break;\n\n            int w = (v | (v - 1)) + 1;\n            w |= (((w & -w) / (v & -v)) >> 1) - 1;\n            v = w & blockMask;\n        }\n    }\n\n    static string Delimit<T>(this IEnumerable<T> source, string separator) => string.Join(separator, source);\n    static string Encase(this string s, char start, char end) => start + s + end;\n}\n"}
{"func": "using System;\n\npublic static class Program\n{\n    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n    static void Main()\n    {\n        Console.WriteLine(FACTORIAL_10);\n    }\n}\n"}
{"func": "using System.Diagnostics;\n\nnamespace RC\n{\n  internal class Program\n  {\n    public static void Main()\n    {\n      string sSource  = \"Sample App\";\n      string sLog     = \"Application\";\n      string sEvent   = \"Hello from RC!\";\n\n      if (!EventLog.SourceExists(sSource))\n        EventLog.CreateEventSource(sSource, sLog);\n\n      EventLog.WriteEntry(sSource, sEvent);\n      EventLog.WriteEntry(sSource, sEvent, EventLogEntryType.Information);\n    }\n  }\n}\n"}
{"func": "using System;\n\n// Func and FuncFunc can be defined using using aliases and the System.Func<T, TReult> type, but RecursiveFunc must be a delegate type of its own.\nusing Func = System.Func<int, int>;\nusing FuncFunc = System.Func<System.Func<int, int>, System.Func<int, int>>;\n\ndelegate Func RecursiveFunc(RecursiveFunc f);\n\nstatic class Program {\n    static void Main() {\n        var fac = Y(almost_fac);\n        var fib = Y(almost_fib);\n        Console.WriteLine(\"fac(10) = \" + fac(10));\n        Console.WriteLine(\"fib(10) = \" + fib(10));\n    }\n\n    static Func Y(FuncFunc f) {\n        RecursiveFunc g = delegate (RecursiveFunc r) {\n            return f(delegate (int x) {\n                return r(r)(x);\n            });\n        };\n        return g(g);\n    }\n\n    static Func almost_fac(Func f) {\n        return delegate (int x) {\n            if (x <= 1) {\n                return 1;\n            }\n            return x * f(x-1);\n        };\n    }\n\n    static Func almost_fib(Func f) {\n        return delegate (int x) {\n            if (x <= 2) {\n                return 1;\n            }\n            return f(x-1)+f(x-2);\n        };\n    }\n}\n"}
{"func": "namespace RosettaCode.GenerateLowerCaseASCIIAlphabet\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal class Program\n    {\n        private static IEnumerable<char> Alphabet\n        {\n            get\n            {\n                for (var character = 'a'; character <= 'z'; character++)\n                {\n                    yield return character;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(string.Empty, Alphabet));\n        }\n    }\n}\n"}
{"func": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        Console.WriteLine(Math.E); //E\n        Console.WriteLine(Math.PI); //PI\n        Console.WriteLine(Math.Sqrt(10)); //Square Root\n        Console.WriteLine(Math.Log(10)); // Logarithm\n        Console.WriteLine(Math.Log10(10)); // Base 10 Logarithm\n        Console.WriteLine(Math.Exp(10)); // Exponential\n        Console.WriteLine(Math.Abs(10)); //Absolute value\n        Console.WriteLine(Math.Floor(10.0)); //Floor\n        Console.WriteLine(Math.Ceiling(10.0)); //Ceiling\n        Console.WriteLine(Math.Pow(2, 5)); // Exponentiation\n    }\n}\n"}
{"func": "using System;\n\n// A delegate declaration. Because delegates are types, they can exist directly in namespaces.\ndelegate int Func2(int a, int b);\n\nclass Program\n{\n    static int Add(int a, int b)\n    {\n        return a + b;\n    }\n\n    static int Mul(int a, int b)\n    {\n        return a * b;\n    }\n\n    static int Div(int a, int b)\n    {\n        return a / b;\n    }\n\n    static int Call(Func2 f, int a, int b)\n    {\n        // Invoking a delegate like a method is syntax sugar; this compiles down to f.Invoke(a, b);\n        return f(a, b);\n    }\n\n    static void Main()\n    {\n        int a = 6;\n        int b = 2;\n\n        // Delegates must be created using the \"constructor\" syntax in C# 1.0; in C# 2.0 and above, only the name of the method is required (when a target type exists, such as in an assignment to a variable with a delegate type or usage in a function call with a parameter of a delegate type; initializers of implicitly typed variables must use the constructor syntax as a raw method has no delegate type). Overload resolution is performed using the parameter types of the target delegate type.\n        Func2 add = new Func2(Add);\n        Func2 mul = new Func2(Mul);\n        Func2 div = new Func2(Div);\n\n        Console.WriteLine(\"f=Add, f({0}, {1}) = {2}\", a, b, Call(add, a, b));\n        Console.WriteLine(\"f=Mul, f({0}, {1}) = {2}\", a, b, Call(mul, a, b));\n        Console.WriteLine(\"f=Div, f({0}, {1}) = {2}\", a, b, Call(div, a, b));\n    }\n}\n"}
{"func": "using System;\nusing System.Linq;\nusing System.Net;\n\nnamespace CsvToHtml\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string csv =\n                @\"Character,Speech\nThe multitude,The messiah! Show us the messiah!\nBrians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>\nThe multitude,Who are you?\nBrians mother,I'm his mother; that's who!\nThe multitude,Behold his mother! Behold his mother!\";\n\n            Console.Write(ConvertCsvToHtmlTable(csv, true));\n        }\n\n        private static string ConvertCsvToHtmlTable(string csvText, bool formatHeaders)\n        {\n            var rows =\n                (from text in csvText.Split(new[] { '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries) /* Split the string by newline,\n                                                                                                          * removing any empty rows. */\n                 select text.Split(',')).ToArray(); // Split each row by comma.\n\n            string output = \"<table>\"; // Initialize the output with the value of \"<table>\".\n\n            for (int index = 0; index < rows.Length; index++) // Iterate through each row.\n            {\n                var row = rows[index];\n                var tag = (index == 0 && formatHeaders) ? \"th\" : \"td\"; /* Check if this is the first row, and if to format headers.\n                                                                        * If so, then set the tags as table headers.\n                                                                        * Otherwise, set the tags as table data. */\n\n                output += \"\\r\\n\\t<tr>\"; // Add table row tag to output string.\n\n                // Add escaped cell data with proper tags to output string for each cell in row.\n                output = row.Aggregate(output,\n                                       (current, cell) =>\n                                       current +\n                                       string.Format(\"\\r\\n\\t\\t<{0}>{1}</{0}>\", tag, WebUtility.HtmlEncode(cell)));\n\n                output += \"\\r\\n\\t</tr>\"; // Add closing table row tag to output string.\n            }\n\n            output += \"\\r\\n</table>\"; // Add closing table tag to output string.\n\n            return output;\n        }\n    }\n}\n"}
{"func": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0)\n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n\n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"func": "using System;\n\ndelegate int Func(int i);\ndelegate Func FuncFunc(Func f);\ndelegate Func RecursiveFunc(RecursiveFunc f);\n\nstatic class Program {\n    static void Main() {\n        var fac = Y(almost_fac);\n        var fib = Y(almost_fib);\n        Console.WriteLine(\"fac(10) = \" + fac(10));\n        Console.WriteLine(\"fib(10) = \" + fib(10));\n    }\n\n    static Func Y(FuncFunc f) {\n        RecursiveFunc g = r => f(x => r(r)(x));\n        return g(g);\n    }\n\n    static Func almost_fac(Func f) => x => x <= 1 ? 1 : x * f(x - 1);\n\n    static Func almost_fib(Func f) => x => x <= 2 ? 1 : f(x - 1) + f(x - 2);\n}\n"}
{"func": "using System;\n\nnamespace PriorityQueue\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PriorityQueue PQ = new PriorityQueue();\n            PQ.push(3, \"Clear drains\");\n            PQ.push(4, \"Feed cat\");\n            PQ.push(5, \"Make tea\");\n            PQ.push(1, \"Solve RC tasks\");\n            PQ.push(2, \"Tax return\");\n\n            while (!PQ.Empty)\n            {\n                var Val = PQ.pop();\n                Console.WriteLine(Val[0] + \" : \" + Val[1]);\n            }\n            Console.ReadKey();\n        }\n    }\n\n    class PriorityQueue\n    {\n        private System.Collections.SortedList PseudoQueue;\n\n        public bool Empty\n        {\n            get\n            {\n                return PseudoQueue.Count == 0;\n            }\n        }\n\n        public PriorityQueue()\n        {\n            PseudoQueue = new System.Collections.SortedList();\n        }\n\n        public void push(object Priority, object Value)\n        {\n            PseudoQueue.Add(Priority, Value);\n        }\n\n        public object[] pop()\n        {\n            object[] ReturnValue = { null, null };\n            if (PseudoQueue.Count > 0)\n            {\n                ReturnValue[0] = PseudoQueue.GetKey(0);\n                ReturnValue[1] = PseudoQueue.GetByIndex(0);\n\n                PseudoQueue.RemoveAt(0);\n            }\n            return ReturnValue;\n        }\n    }\n}\n"}
{"func": "using NUnit.Framework;\nusing PalindromeDetector.ConsoleApp;\n\nnamespace PalindromeDetector.VisualStudioTests\n{\n    [TestFixture]\n    public class NunitTests\n    {\n        [Test]\n        public void PalindromeDetectorCanUnderstandPalindrome()\n        {\n            //nunit.framework v2.0.50727\n            bool expected = true;\n            bool actual;\n            actual = Program.IsPalindrome(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindrome(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n        }\n        [Test]\n        public void PalindromeDetectorUnderstandsNonPalindrome()\n        {\n            bool notExpected = true;\n            bool actual;\n            actual = Program.IsPalindrome(\"NotAPalindrome\");\n            Assert.AreEqual(notExpected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"NotAPalindrome\");\n            Assert.AreEqual(notExpected, actual);\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class PartialApplicationDynamic\n{\n    // Create a matching delegate type to simplify delegate creation.\n    delegate IEnumerable<TResult> fsDelegate<TSource, TResult>(Func<TSource, TResult> f, IEnumerable<TSource> s);\n\n    static IEnumerable<TResult> fs<TSource, TResult>(Func<TSource, TResult> f, IEnumerable<TSource> s) => s.Select(f);\n\n    static dynamic f1(dynamic x) => x * 2;\n\n    static dynamic f2(dynamic x) => x * x;\n\n    static T[] ArrayConcat<T>(T[] arr1, T[] arr2)\n    {\n        var result = new T[arr1.Length + arr2.Length];\n        Array.Copy(arr1, result, arr1.Length);\n        Array.Copy(arr2, 0, result, 1, arr2.Length);\n        return result;\n    }\n\n    // Use a specialized params delegate to simplify calling at the risk of inadvertent params expansion.\n    delegate TResult partialDelegate<TParams, TResult>(params TParams[] args);\n    static partialDelegate<dynamic, TResult> PartialApplyDynamic<TDelegate, TResult>(TDelegate f, params dynamic[] args) where TDelegate : Delegate\n    {\n        return rest => (TResult)f.DynamicInvoke(ArrayConcat(args, rest).Cast<dynamic>().ToArray());\n    }\n\n    static void Main()\n    {\n        // Cast to object to avoid params expansion of the arrays.\n        object args1 = new object[] { 0, 1, 2, 3 };\n        object args2 = new object[] { 2, 4, 6, 8 };\n\n        var fsf1 = PartialApplyDynamic<fsDelegate<dynamic, dynamic>, IEnumerable<dynamic>>(fs, new Func<dynamic, dynamic>(f1));\n        var fsf2 = PartialApplyDynamic<fsDelegate<dynamic, dynamic>, IEnumerable<dynamic>>(fs, new Func<dynamic, dynamic>(f2));\n\n        Console.WriteLine(\"fsf1, 0-3: \" + string.Join(\", \", fsf1(args1)));\n        Console.WriteLine(\"fsf1, evens: \" + string.Join(\", \", fsf1(args2)));\n        Console.WriteLine(\"fsf2, 0-3: \" + string.Join(\", \", fsf2(args1)));\n        Console.WriteLine(\"fsf2, evens: \" + string.Join(\", \", fsf2(args2)));\n    }\n}\n"}
{"func": "using System;\nusing System.Text;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        WebClient wc = new WebClient();\n        string content = wc.DownloadString(\"http://www.google.com\");\n        Console.WriteLine(content);\n    }\n}\n"}
{"func": "using System;\n\nstatic class Program\n{\n  // Purpose: Apply a callback (or anonymous method) to an Array\n  // Output: Prints the squares of an int array to the console.\n  // Compiler: Visual Studio 2005\n  // Framework: .net 2\n\n  [STAThread]\n  public static void Main()\n  {\n    int[] intArray = { 1, 2, 3, 4, 5 };\n\n    // Using a callback,\n    Console.WriteLine(\"Printing squares using a callback:\");\n    Array.ForEach<int>(intArray, PrintSquare);\n\n    // or using an anonymous method:\n    Console.WriteLine(\"Printing squares using an anonymous method:\");\n    Array.ForEach<int>\n    (\n      intArray,\n      delegate(int value)\n      {\n        Console.WriteLine(value * value);\n      });\n  }\n\n  public static void PrintSquare(int value)\n  {\n    Console.WriteLine(value * value);\n  }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\n\nList<int> list = new List<int>();\n\nlist.Add(1);\nlist.Add(3);\n\nlist[0] = 2;\n\nConsole.WriteLine(list[0]);\n"}
{"func": "using System;\nusing System.Linq;\n\nnamespace IdentityMatrix\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            if (args.Length != 1)\n            {\n                Console.WriteLine(\"Requires exactly one argument\");\n                return;\n            }\n            int n;\n            if (!int.TryParse(args[0], out n))\n            {\n                Console.WriteLine(\"Requires integer parameter\");\n                return;\n            }\n\n            var identity =\n                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();\n            foreach (var row in identity)\n            {\n                foreach (var elem in row)\n                {\n                    Console.Write(\" \" + elem);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\n\nnamespace Sutherland\n{\n    public partial class MainWindow : Window\n    {\n        #region Declaration Section\n\n        private Random _rand = new Random();\n\n        private Brush _subjectBack = new SolidColorBrush(ColorFromHex(\"30427FCF\"));\n        private Brush _subjectBorder = new SolidColorBrush(ColorFromHex(\"427FCF\"));\n        private Brush _clipBack = new SolidColorBrush(ColorFromHex(\"30D65151\"));\n        private Brush _clipBorder = new SolidColorBrush(ColorFromHex(\"D65151\"));\n        private Brush _intersectBack = new SolidColorBrush(ColorFromHex(\"609F18CC\"));\n        private Brush _intersectBorder = new SolidColorBrush(ColorFromHex(\"9F18CC\"));\n\n        #endregion\n\n        #region Constructor\n\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        #endregion\n\n        #region Event Listeners\n\n        private void btnTriRect_Click(object sender, RoutedEventArgs e)\n        {\n            try\n            {\n                double width = canvas.ActualWidth;\n                double height = canvas.ActualHeight;\n\n                Point[] poly1 = new Point[] {\n\t\t\t\t    new Point(_rand.NextDouble() * width, _rand.NextDouble() * height),\n\t\t\t\t    new Point(_rand.NextDouble() * width, _rand.NextDouble() * height),\n\t\t\t\t    new Point(_rand.NextDouble() * width, _rand.NextDouble() * height) };\n\n                Point rectPoint = new Point(_rand.NextDouble() * (width * .75d), _rand.NextDouble() * (height * .75d));\t\t//\tdon't let it start all the way at the bottom right\n                Rect rect = new Rect(\n                    rectPoint,\n                    new Size(_rand.NextDouble() * (width - rectPoint.X), _rand.NextDouble() * (height - rectPoint.Y)));\n\n                Point[] poly2 = new Point[] { rect.TopLeft, rect.TopRight, rect.BottomRight, rect.BottomLeft };\n\n                Point[] intersect = SutherlandHodgman.GetIntersectedPolygon(poly1, poly2);\n\n                canvas.Children.Clear();\n                ShowPolygon(poly1, _subjectBack, _subjectBorder, 1d);\n                ShowPolygon(poly2, _clipBack, _clipBorder, 1d);\n                ShowPolygon(intersect, _intersectBack, _intersectBorder, 3d);\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString(), this.Title, MessageBoxButton.OK, MessageBoxImage.Error);\n            }\n        }\n        private void btnConvex_Click(object sender, RoutedEventArgs e)\n        {\n            try\n            {\n                Point[] poly1 = new Point[] { new Point(50, 150), new Point(200, 50), new Point(350, 150), new Point(350, 300), new Point(250, 300), new Point(200, 250), new Point(150, 350), new Point(100, 250), new Point(100, 200) };\n                Point[] poly2 = new Point[] { new Point(100, 100), new Point(300, 100), new Point(300, 300), new Point(100, 300) };\n\n                Point[] intersect = SutherlandHodgman.GetIntersectedPolygon(poly1, poly2);\n\n                canvas.Children.Clear();\n                ShowPolygon(poly1, _subjectBack, _subjectBorder, 1d);\n                ShowPolygon(poly2, _clipBack, _clipBorder, 1d);\n                ShowPolygon(intersect, _intersectBack, _intersectBorder, 3d);\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString(), this.Title, MessageBoxButton.OK, MessageBoxImage.Error);\n            }\n        }\n\n        #endregion\n\n        #region Private Methods\n\n        private void ShowPolygon(Point[] points, Brush background, Brush border, double thickness)\n        {\n            if (points == null || points.Length == 0)\n            {\n                return;\n            }\n\n            Polygon polygon = new Polygon();\n            polygon.Fill = background;\n            polygon.Stroke = border;\n            polygon.StrokeThickness = thickness;\n\n            foreach (Point point in points)\n            {\n                polygon.Points.Add(point);\n            }\n\n            canvas.Children.Add(polygon);\n        }\n\n        /// <summary>\n        /// This is just a wrapper to the color converter (why can't they have a method off the color class with all\n        /// the others?)\n        /// </summary>\n        private static Color ColorFromHex(string hexValue)\n        {\n            if (hexValue.StartsWith(\"#\"))\n            {\n                return (Color)ColorConverter.ConvertFromString(hexValue);\n            }\n            else\n            {\n                return (Color)ColorConverter.ConvertFromString(\"#\" + hexValue);\n            }\n        }\n\n        #endregion\n    }\n}\n"}
{"func": "using System;\nusing System.Numerics;\n\nclass Program {\n\n  const int MaxPow = 301;\n  static int [] sq = {1, 4, 9, 16, 25, 36, 49, 64, 81};\n  static BigInteger [] sums;\n\n  static bool is89(int x) {\n    while (true) {\n      int s = 0, t;\n      do if ((t = (x % 10) - 1) >= 0) s += sq[t]; while ((x /= 10) > 0);\n      if (s == 89) return true;\n      if (s == 1) return false;\n      x = s;\n    }\n  }\n\n  static BigInteger count89(int n) {\n      BigInteger result = 0;\n      for (int i = n * 81; i > 0; i--) {\n        foreach (int s in sq) { if(s > i) break; sums[i] += sums[i - s]; }\n        if (is89(i)) result += sums[i];\n      }\n      return result;\n  }\n\n  static void Main(string[] args) {\n    BigInteger [] t = new BigInteger[2] {1, 0}; sums = new BigInteger[MaxPow * 81]; Array.Copy(t, sums, t.Length);\n    DateTime st = DateTime.Now;\n    for (int n = 1; n < MaxPow; n++) {\n      Console.Write(\"1->10^{0,-3}: {1}\\n\", n, count89(n));\n      if ((DateTime.Now - st).TotalSeconds > 6) break;\n    }\n    Console.WriteLine(\"{0} seconds elapsed.\", (DateTime.Now - st).TotalSeconds);\n  }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Zeckendorf\n{\n    class Program\n    {\n        private static uint Fibonacci(uint n)\n        {\n            if (n < 2)\n            {\n                return n;\n            }\n            else\n            {\n                return Fibonacci(n - 1) + Fibonacci(n - 2);\n            }\n        }\n\n        private static string Zeckendorf(uint num)\n        {\n            IList<uint> fibonacciNumbers = new List<uint>();\n            uint fibPosition = 2;\n\n            uint currentFibonaciNum = Fibonacci(fibPosition);\n\n            do\n            {\n                fibonacciNumbers.Add(currentFibonaciNum);\n                currentFibonaciNum = Fibonacci(++fibPosition);\n            } while (currentFibonaciNum <= num);\n\n            uint temp = num;\n            StringBuilder output = new StringBuilder();\n\n            foreach (uint item in fibonacciNumbers.Reverse())\n            {\n                if (item <= temp)\n                {\n                    output.Append(\"1\");\n                    temp -= item;\n                }\n                else\n                {\n                    output.Append(\"0\");\n                }\n            }\n\n            return output.ToString();\n        }\n\n        static void Main(string[] args)\n        {\n            for (uint i = 1; i <= 20; i++)\n            {\n                string zeckendorfRepresentation = Zeckendorf(i);\n                Console.WriteLine(string.Format(\"{0} : {1}\", i, zeckendorfRepresentation));\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"func": "using System;\npublic delegate int IntFunction(int a, int b);\n\npublic class Program\n{\n    public static int Add(int x, int y) {\n        return x + y;\n    }\n\n    public static int Multiply(int x, int y) {\n        return x * y;\n    }\n\n    public static void Main() {\n        IntFunction func = Add;\n        Console.WriteLine(func(2, 3)); //prints 5\n        func = Multiply;\n        Console.WriteLine(func(2, 3)); //prints 6\n        func += Add;\n        Console.WriteLine(func(2, 3)); //prints 5. Both functions are called, but only the last result is kept.\n    }\n}\n"}
{"func": "using System;\n\nclass Program {\n    interface Func {\n        int apply(int i);\n    }\n\n    interface FuncFunc {\n        Func apply(Func f);\n    }\n\n    interface RecursiveFunc {\n        Func apply(RecursiveFunc f);\n    }\n\n    class Y {\n        class __1 : RecursiveFunc {\n            class __2 : Func {\n                readonly RecursiveFunc w;\n\n                public __2(RecursiveFunc w) {\n                    this.w = w;\n                }\n\n                public int apply(int x) {\n                    return w.apply(w).apply(x);\n                }\n            }\n\n            readonly FuncFunc f;\n\n            public __1(FuncFunc f) {\n                this.f = f;\n            }\n\n            public Func apply(RecursiveFunc w) {\n                return f.apply(new __2(w));\n            }\n        }\n\n        public static Func _(FuncFunc f) {\n            __1 r = new __1(f);\n            return r.apply(r);\n        }\n    }\n\n    class __fib : FuncFunc {\n        class __1 : Func {\n            readonly Func f;\n\n            public __1(Func f) {\n                this.f = f;\n            }\n\n            public int apply(int n) {\n                return\n                    (n <= 2)\n                  ? 1\n                  : (f.apply(n - 1) + f.apply(n - 2));\n            }\n\n        }\n\n        public Func apply(Func f) {\n            return new __1(f);\n        }\n    }\n\n    class __fac : FuncFunc {\n        class __1 : Func {\n            readonly Func f;\n\n            public __1(Func f) {\n                this.f = f;\n            }\n\n            public int apply(int n) {\n                return\n                    (n <= 1)\n                  ? 1\n                  : (n * f.apply(n - 1));\n            }\n        }\n\n        public Func apply(Func f) {\n            return new __1(f);\n        }\n    }\n\n    static void Main(params String[] arguments) {\n        Func fib = Y._(new __fib());\n        Func fac = Y._(new __fac());\n\n        Console.WriteLine(\"fib(10) = \" + fib.apply(10));\n        Console.WriteLine(\"fac(10) = \" + fac.apply(10));\n    }\n}\n"}
{"func": "using System;\n\ninterface IOperable\n{\n    string Operate();\n}\n\nclass Inoperable\n{\n}\n\nclass Operable : IOperable\n{\n    public string Operate()\n    {\n        return \"Delegate implementation.\";\n    }\n}\n\nclass Delegator : IOperable\n{\n    object Delegate;\n\n    public string Operate()\n    {\n        var operable = Delegate as IOperable;\n        return operable != null ? operable.Operate() : \"Default implementation.\";\n    }\n\n    static void Main()\n    {\n        var delegator = new Delegator();\n        foreach (var @delegate in new object[] { null, new Inoperable(), new Operable() })\n        {\n            delegator.Delegate = @delegate;\n            Console.WriteLine(delegator.Operate());\n        }\n    }\n}\n"}
{"func": "using System.Collections.Generic;\nusing System.Linq;\n\nvoid Main()\n{\n\tList<string> blocks =\n\tnew List<string>() { \"bo\", \"xk\", \"dq\", \"cp\", \"na\", \"gt\", \"re\", \"tg\", \"qd\", \"fs\",\n\t\t\"jw\", \"hu\", \"vi\", \"an\", \"ob\", \"er\", \"fs\", \"ly\", \"pc\", \"zm\" };\n\tList<string> words = new List<string>() {\n\t\t\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"};\n\t\n\tvar solver = new ABC(blocks);\n\t\n\tforeach( var word in words)\n\t{\n\t\tConsole.WriteLine(\"{0} :{1}\", word, solver.CanMake(word));\n\t}\n}\n\nclass ABC\n{\n\treadonly Dictionary<char, List<int>> _blockDict = new Dictionary<char, List<int>>();\n\tbool[] _used;\n\tint _nextBlock;\n\n\treadonly List<string> _blocks;\n\n\tprivate void AddBlockChar(char c)\n\t{\n\t\tif (!_blockDict.ContainsKey(c))\n\t\t{\n\t\t\t_blockDict[c] = new List<int>();\n\t\t}\n\t\t_blockDict[c].Add(_nextBlock);\n\t}\n\n\tprivate void AddBlock(string block)\n\t{\n\t\tAddBlockChar(block[0]);\n\t\tAddBlockChar(block[1]);\n\t\t_nextBlock++;\n\t}\n\n\tpublic ABC(List<string> blocks)\n\t{\n\t\t_blocks = blocks;\n\t\tforeach (var block in blocks)\n\t\t{\n\t\t\tAddBlock(block);\n\t\t}\n\t}\n\n\tpublic bool CanMake(string word)\n\t{\n\t\tword = word.ToLower();\n\t\tif (word.Length > _blockDict.Count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t_used = new bool[_blocks.Count];\n\t\treturn TryMake(word);\n\t}\n\n\tpublic bool TryMake(string word)\n\t{\n\t\tif (word == string.Empty)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvar blocks = _blockDict[word[0]].Where(b => !_used[b]);\n\t\tforeach (var block in blocks)\n\t\t{\n\t\t\t_used[block] = true;\n\t\t\tif (TryMake(word.Substring(1)))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t_used[block] = false;\n\t\t}\n\t\treturn false;\n\t}\n}\n"}
{"func": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int abundant, deficient, perfect;\n        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}\");\n\n        ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}\");\n    }\n}\n\npublic static class ClassifyNumbers\n{\n    //Fastest way\n    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {\n        int a = 0, d = 0, p = 0;\n        //For very large bounds, this array can get big.\n        int[] sum = new int[bound + 1];\n        for (int divisor = 1; divisor <= bound / 2; divisor++) {\n            for (int i = divisor + divisor; i <= bound; i += divisor) {\n                sum[i] += divisor;\n            }\n        }\n        for (int i = 1; i <= bound; i++) {\n            if (sum[i] < i) d++;\n            else if (sum[i] > i) a++;\n            else p++;\n        }\n        abundant = a;\n        deficient = d;\n        perfect = p;\n    }\n\n    //Much slower, but doesn't use storage\n    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        int a = 0, d = 0, p = 0;\n        for (int i = 1; i < 20001; i++) {\n            int sum = Enumerable.Range(1, (i + 1) / 2)\n                .Where(div => div != i && i % div == 0).Sum();\n            if (sum < i) d++;\n            else if (sum > i) a++;\n            else p++;\n        }\n        abundant = a;\n        deficient = d;\n        perfect = p;\n    }\n}\n"}
{"func": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass RangeExtraction\n{\n    static void Main()\n    {\n        const string testString = \"0,  1,  2,  4,  6,  7,  8, 11, 12, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24,25, 27, 28, 29, 30, 31, 32, 33, 35, 36,37, 38, 39\";\n        var result = String.Join(\",\", RangesToStrings(GetRanges(testString)));\n        Console.Out.WriteLine(result);\n    }\n\n    public static IEnumerable<IEnumerable<int>> GetRanges(string testString)\n    {\n        var numbers = testString.Split(new[] { ',' }).Select(x => Convert.ToInt32(x));\n        var current = new List<int>();\n        foreach (var n in numbers)\n        {\n            if (current.Count == 0)\n            {\n                current.Add(n);\n            }\n            else\n            {\n                if (current.Max() + 1 == n)\n                {\n                    current.Add(n);\n                }\n                else\n                {\n                    yield return current;\n                    current = new List<int> { n };\n                }\n            }\n        }\n        yield return current;\n    }\n\n    public static IEnumerable<string> RangesToStrings(IEnumerable<IEnumerable<int>> ranges)\n    {\n        foreach (var range in ranges)\n        {\n            if (range.Count() == 1)\n            {\n                yield return range.Single().ToString();\n            }\n            else if (range.Count() == 2)\n            {\n                yield return range.Min() + \",\" + range.Max();\n            }\n            else\n            {\n                yield return range.Min() + \"-\" + range.Max();\n            }\n        }\n    }\n}\n"}
